[{"content":"1.Sentinel工作原理 学习Sentinel关注3点\n1.如何定义资源 2.如何定义规则 3.如何处理规则 2.下载Sentinel客户端 home | Sentinel\n下载连接：https://github.com/alibaba/Sentinel/releases/tag/1.8.8\n1 java -jar sentinel-dashboard-1.8.8.jar 启动后访问127.0.0.1:8080端口，默认账户密码为sentinel:sentinel\n3.Sentinel结合业务 导入Sentinel依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 编辑配置文件连接Sentinel服务器地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 spring: cloud: openfeign: client: config: product-service: # 只针对product-service服务的配置 connect-timeout: 5000 # 连接超时时间 read-timeout: 5000 # 读取超时时间 logger-level: full # 日志级别 default: # 所有其它服务的默认配置 connect-timeout: 5000 # 连接超时时间 read-timeout: 10000 # 读取超时时间 logger-level: full # 日志级别 Sentinel: transport: dashboard: localhost:8080 # sentinel控制台地址 eager: true # 启动时就初始化sentinel规则 此时启动项目就连接成功\n那么如何通过Sentinel实现监控呢，在你需要监控的资源上加上@SentinelResource注解表示这个方法是Sentinel监控的资源\n此时如果我们请求这个路由，Sentinel就会接收到这个请求，根据我们在Sentinel上定义的规则对请求进行拦截或放行\n通过Sentinel定义流控规则限制并发数，此时我限制每次发送的请求最多为1次\n当我访问过快时，业务端直接报错\n4.Sentinel异常处理 Web异常自定义处理异常 由于默认的异常处理是Sentinel的默认错误页，如果我们想对这个异常处理进行优化该怎么操作呢\n想要异常处理为自己定义的就要自己写一个BlockExceptionHandler\n在模型层定义一个处理异常的JavaBean，给上构造方法\n定义一个处理异常的类MyExceptionHandler实现BlockExceptionHandler方法，重写里面的handle方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package com.example.exception; import com.alibaba.csp.sentinel.adapter.spring.webmvc_v6x.callback.BlockExceptionHandler; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.example.bean.common.R; import com.fasterxml.jackson.databind.ObjectMapper; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; import org.springframework.stereotype.Component; import java.io.PrintWriter; @Component public class MyExceptionHandler implements BlockExceptionHandler { private ObjectMapper objectMapper = new ObjectMapper(); @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, String s, BlockException e) throws Exception { httpServletResponse.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); httpServletResponse.setContentType(\u0026#34;application/json\u0026#34;); PrintWriter writer = httpServletResponse.getWriter(); R error = R.error(500, \u0026#34;系统繁忙，请稍后再试\u0026#34;); String json = objectMapper.writeValueAsString(error); writer.write(json); } } 4.4.2.@SentinelResource异常处理器 一句话总结：@SentinelResource如果标注了blockhandler注解，那就是由blockhandler处理异常，如果没有标注blockhandler属性标注了fallback属性，那么就是由fallback来处理异常，如果一个属性都没有标只取了个名字，那么异常就会没人管向上抛出，最好由SpringBoot来进行处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //当请求符合Sentinel的要求时，直接走CreateOrder方法并返回真实数据 //当请求不符合Sentinel的规则时，会走blockHandler中的CreateOrderBlockHandler方法，并调用兜底回调 @Override @SentinelResource(value = \u0026#34;createOrder\u0026#34;, blockHandler = \u0026#34;CreateOrderBlockHandler\u0026#34;) public order CreateOrder(Long userId, Long productId) { order order = new order(); product product = productFeignClient.getProductById(productId); //product product = getProductFromRemote2(productId); order.setId(1L); //计算订单总金额 order.setTotalAmount(product.getPrice().multiply(new BigDecimal(\u0026#34;10\u0026#34;))); order.setUserId(userId); order.setNikeName(\u0026#34;zhangsan\u0026#34;); order.setAddress(\u0026#34;beijing\u0026#34;); //远程查询商品信息，并设置到订单中 order.setProductList(Arrays.asList(product)); return order; } public order CreateOrderBlockHandler(Long userId, Long productId, BlockException e) { order order = new order(); order.setId(0L); //计算订单总金额 order.setTotalAmount(new BigDecimal(\u0026#34;0\u0026#34;)); order.setUserId(userId); order.setNikeName(\u0026#34;未知用户\u0026#34;); order.setAddress(\u0026#34;异常信息\u0026#34;+e.getMessage()); return order; } 4.4.3.OpenFeign调用 可以从链路数据中看出链路一直到达OpenFeign远程调用地址，如果我们在远程调用地址上添加流控会发生什么呢\n当请求过快时会看到页面返回OpenFeign兜底回调数据，原因是我们之前在OpenFeign接口上写过兜底回调fallback，如果请求失败并且项目中有兜底数据，那么就会显示兜底数据，如果没有写兜底回调，那么就会往上抛，知道SpringBoot来进行处理\n4.4.4.Sphu硬编码方式处理异常 1 2 3 4 5 6 7 try { SphU.entry(\u0026#34;createOrder\u0026#34;); //项目原生代码 } catch (BlockException e) { //进行异常处理逻辑，比如返回默认值或者抛出异常等 throw new RuntimeException(e); } 5.Sentinel流控规则 阈值类型：QPS和并发线程数的区别\nQPS：指每秒允许通过的请求数量，基于时间窗口统计，底层采用计数器来计数\n并发线程数：适用于代码中使用了线程池，比较复杂，也是每秒运行通过的请求数量\n集群阈值模式：\n单机均摊：假设总请求为30，有3个集群，那么每个集群均摊10个请求\n总体阈值：假设总体阈值请求为10，有3个集群，那么每个集群处理3个请求\n5.1.流控模式（直接/关联/链路） 链路规则 比如有这样一个场景：订单创建时分为普通创建订单和秒杀创建订单两种情况，我在createOrder资源中流控模式选择链路模式，入口资源选择秒杀创建订单资源名，那么当请求过快时，普通创建订单不受影响，秒杀创建订单会加载兜底数据\n关联规则 当系统中两个资源存在竞争关系时通常使用关联规则\n当writedb的流量特别大时，readdb才会被限制\n5.2.流控效果（快速失败/Warm up/排队等待） 快速失败 当请求流量超出阈值规则时，多余的请求直接会抛出异常\nWarm Up（预热/冷启动） 匀速排队 以前超过的请求都是直接丢掉，匀速排队中多出来的请求一个一个排队，当排队市场超过预期时间，请求就会被丢弃\n6.熔断规则 断路器工作原理\n6.1.慢调用比例 解释一下这张图：\n5秒内所有响应超过1秒的请求都为慢调用请求，如果慢调用请求超过总请求的80%，那么这个请求是不可靠的，那么断路器会熔断30S,这30S期间所有请求均返回错误\n6.2.异常比例 5秒内向远程发送请求，如果有80%请求出现异常，那么断路器会打开熔断20秒，这20秒不会在给远程发送请求\n6.3.异常数 5秒内不管你发送多少请求，只要你请求中有10个存在异常，那么就直接触发熔断规则\n7.热点规则 parameter-flow-control | Sentinel\n何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：\n商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制 用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制 热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。\n1 2 3 普通用户秒杀QPS不超过1 vip用户秒杀QPS不限制 666号是下架商品，不允许访问 参数索引这第一个0方法签名的表示第一个参数，单机阈值表示参数的个数\n高级选项中参数值为6表示userId为6的用户不限流\n当服务重启后Sentinel中的所有规则都会失效，如果想要持久化，可以结合Nacos和Mysql数据库实现持久化\n","date":"2025-06-08T23:44:41+08:00","image":"https://lserein.github.io/p/sentinel/Sentinel_hu_2c5df63c709ebee8.jpg","permalink":"https://lserein.github.io/p/sentinel/","title":"Sentinel"},{"content":"OpenFeign\u0026mdash;远程调用 使用OpenFeign进行远程调用 向第三方微服务API发送请求 小Tips：向自己的业务API发送请求直接复制对方业务Controller层方法即可\n前面使用的是restTemplate进行远程调用，但是使用restTemplate进行远程调用比较麻烦，这里我们使用OpenFeign改写代码\n导入依赖，创建ProductFeignClient接口\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 restTemplate package com.example.feign; import com.example.bean.product; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @FeignClient(value = \u0026#34;product-service\u0026#34;) //Feign客户端，指定要请求的服务名称 public interface ProductFeignClient { //MVC注解两套逻辑 //标注在controller上，是接收http请求 //标注在feign上，是用来发送http请求 @GetMapping(\u0026#34;/product/{productId}\u0026#34;) //指定远程服务接口 product getProductById(@PathVariable(\u0026#34;productId\u0026#34;) Long productId); } 将ProductFeignClient进行依赖注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Autowired ProductFeignClient productFeignClient; @Override public order CreateOrder(Long userId, Long productId) { order order = new order(); //调用接口的方法发送请求 product product = productFeignClient.getProductById(productId); //不需要自己在写getProductFromRemote2方法 //product product = getProductFromRemote2(productId); order.setId(1L); //计算订单总金额 order.setTotalAmount(product.getPrice().multiply(new BigDecimal(\u0026#34;10\u0026#34;))); order.setUserId(userId); order.setNikeName(\u0026#34;zhangsan\u0026#34;); order.setAddress(\u0026#34;beijing\u0026#34;); //远程查询商品信息，并设置到订单中 order.setProductList(Arrays.asList(product)); return order; } 第三方API远程调用 比如我不需要像注册中心发请求，我想像第三方API发送请求，如：墨迹天气等等\n使用FeignClient绑定第三方API的URL，根据对应请求方法发送对应请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.example.feign; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; //https://v.api.aa1.cn/api/api-tianqi-3/index.php?msg=%E5%A4%A9%E6%B4%A5\u0026amp;type=1 @FeignClient(value = \u0026#34;weather\u0026#34;,url = \u0026#34;https://v.api.aa1.cn/api/api-tianqi-3/index.php\u0026#34;) public interface WeatherFeignClient { @GetMapping(\u0026#34;/api/api-tianqi-3/index.php\u0026#34;) String getWeather(@RequestParam(\u0026#34;msg\u0026#34;) String msg, @RequestParam(\u0026#34;type\u0026#34;) String type); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example; import com.example.feign.WeatherFeignClient; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest public class WeatherTest { @Autowired WeatherFeignClient weatherFeignClient; @Test void test(){ String weather = weatherFeignClient.getWeather(\u0026#34;北京\u0026#34;, \u0026#34;1\u0026#34;); System.out.println(weather); } } 客户端负载均衡与服务端负载均衡？\nOpenFeign进阶配置 开启请求日志功能 在yml配置文件中配置日志的范围\n1 2 3 logging: level: com.example.feign: debug 在config配置类中配置一个Bean\n1 2 3 4 @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; } 再次运行测试类，请求的详细信息（请求方法，路径，参数都会展示）\n超时控制 超时有两种超时，连接超时（默认10秒）和读取超时（默认60秒）\n可以新创建一个配置文件，如果其它配置文件想要使用这个配置文件的话只需要引用即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 spring: cloud: openfeign: client: config: product-service: # 只针对product-service服务的配置 connect-timeout: 10000 # 连接超时时间 read-timeout: 10000 # 读取超时时间 logger-level: full # 日志级别 default: # 所有其它服务的默认配置 connect-timeout: 20000 # 连接超时时间 read-timeout: 30000 # 读取超时时间 logger-level: full # 日志级别 重试机制 在config配置类中自定义一个重试器retryer，Spring提供默认的retryer，默认最大重试5次，每次最大间隔1秒\n1 2 3 4 5 @Bean Retryer retryer() { //最多重试3次，每次最大间隔10秒，最小间隔1秒 return new Retryer.Default(1000, 10000, 3); } 拦截器 创建好后可以将这个拦截器在配置文件中声明也可以将它设置为Bean，自动调用拦截\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.interceptor; import feign.RequestInterceptor; import feign.RequestTemplate; import org.springframework.stereotype.Component; import java.util.UUID; @Component public class TokenRequestInterceptor implements RequestInterceptor { /* * 请求拦截器需要实现RequestInterceptor接口的apply方法 * 该方法会在请求发送之前被调用 * 可以在该方法中添加请求头、请求参数等 * 这里我们可以通过RequestTemplate对象来添加请求头 * 例如：requestTemplate.header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + token); * */ @Override public void apply(RequestTemplate requestTemplate) { System.out.println(\u0026#34;拦截器执行了\u0026#34;); requestTemplate.header(\u0026#34;Authorization\u0026#34;, UUID.randomUUID().toString()); } } Fallback兜底返回 使用Fallback兜底返回机制需要引入sentinel依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在配置文件中将feign.sentinel.enable设置为true\n1 2 3 feign: sentinel: enabled: true # 开启feign对sentinel的支持 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.example.feign.fallback; import com.example.bean.product; import com.example.feign.ProductFeignClient; import org.springframework.stereotype.Component; import java.math.BigDecimal; @Component public class ProductFeignClientFallback implements ProductFeignClient { @Override public product getProductById(Long productId) { System.out.println(\u0026#34;兜底回调\u0026#34;); product product = new product(); product.setId(productId); product.setProductName(\u0026#34;兜底回调商品\u0026#34;); product.setPrice(new BigDecimal(\u0026#34;1000.00\u0026#34;)); product.setNum(10); return product; } } 如果正常请求无法完成请求，那么会走兜底回调方法，返回默认数据\n","date":"2025-06-08T15:08:01+08:00","image":"https://lserein.github.io/p/openfeign/OpenFeign_hu_f854ac1c3ea4ac46.jpg","permalink":"https://lserein.github.io/p/openfeign/","title":"OpenFeign"},{"content":"Nacos\u0026mdash;注册中心\u0026amp;配置中心 Nacos官网| Nacos 配置中心 | Nacos 下载| Nacos 官方社区\n什么是注册中心Nacos Nacos两大核心功能：服务注册与服务发现\n安装Nacos https://nacos.io/download/release-history/?spm=5238cd80.2ef5001f.0.0.3f613b7c4NDiBh\n直接下载zip压缩包，解压后运行即可\n1 startup.cmd -m standalone 访问:http://127.0.0.1:8848/nacos\nNacos服务注册功能 启动微服务 在service-order微服务模块中写一个SpringBoot的启动类\n创建配置文件application.properties\n1 2 3 spring.application.name=service-order //服务名称 sercer.port=8000 //服务启动端口 spring.cloud.nacos.server-addr=127.0.0.1:8848 //nacos地址 此时访问本地nacos服务器，发现nacos中存在service-order即注册成功\n集群模式启动测试 控制台右键复制配置\n编辑配置，将端口改一下运行即可，如下图所示\n此时nacos注册中心实例数就有3个了\nNacos服务发现 开启服务发现功能 在SpringBoot的启动类中添加注解@EnableDiscoveryClient\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient //开启服务注册与发现功能 @SpringBootApplication public class ProductApplication { public static void main(String[] args) { SpringApplication.run(ProductApplication.class, args); } } 测试服务发现API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class productTest { @Autowired DiscoveryClient discoveryClient; @Test public void discoveryClient() { // 服务注册与发现功能的测试代码 discoveryClient.getServices().forEach(service -\u0026gt; System.out.println(\u0026#34;service\u0026#34;+service) ); //获取服务的IP和端口信息 discoveryClient.getInstances(\u0026#34;product-service\u0026#34;).forEach(instance -\u0026gt; System.out.println(\u0026#34;instance\u0026#34;+instance.getHost()+\u0026#34;\\n\u0026#34;+instance.getPort()+\u0026#34;\\n\u0026#34;+instance.getUri()) ); } } 使用nacosServiceDiscovery进行服务发现测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired NacosServiceDiscovery nacosServiceDiscovery; //获取服务信息 @Test void nacosServiceDiscovery() throws NacosException { // 服务注册与发现功能的测试代码 nacosServiceDiscovery.getServices().forEach(service -\u0026gt; System.out.println(\u0026#34;service\u0026#34;+service) ); //获取服务的IP和端口信息 nacosServiceDiscovery.getInstances(\u0026#34;product-service\u0026#34;).forEach(instance -\u0026gt; System.out.println(\u0026#34;instance\u0026#34;+instance.getHost()+\u0026#34;\\n\u0026#34;+instance.getPort()) ); } 4.远程调用\u0026mdash;下单场景 远程调用基本流程\n首先要定义两个微服务模块，分别是order模块和product模块，分别在这两个模块中编写对应的逻辑代码，这两个模块不需要写实体类pojo，将所有微服务的实体类抽取出来放到model模块统一管理\norder和product模块要使用实体类直接在pom文件中加载依赖即可，如果不这样做的话如果订单模块要使用product模块就会很麻烦\n负载均衡API测试 根据配置的策略从可用实例中选择一个，默认使用轮询算法，这次调用9001，下次调用9002，在又是9001\n1 2 3 4 5 //在order的pom文件中引入对应依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-loadbalancer\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @SpringBootTest public class LoadBalancerTest { LoadBalancerClient loadBalancerClient; @Test public void test(){ ServiceInstance choose = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose.getHost()+\u0026#34;:\u0026#34;+choose.getPort()); ServiceInstance choose1 = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose1.getHost()+\u0026#34;:\u0026#34;+choose1.getPort()); ServiceInstance choose2 = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose2.getHost()+\u0026#34;:\u0026#34;+choose2.getPort()); } } 使用@LoadBanlancer注解完成负载均衡调用 1 2 3 4 5 6 //将注解放到远程调用客户端上即可 @LoadBalanced @Bean public RestTemplate restTemplate() { return new RestTemplate(); } 1 2 3 4 5 6 7 8 9 10 private product getProductFromRemote2(Long productId) { // 1. 获取商品服务所在的 IP 地址 // 2. 构造请求 URL，product-service微服务的IP地址 String url = \u0026#34;http://product-service/product/\u0026#34; + productId; // 3. 发送请求，获取商品信息 log.info(\u0026#34;请求URL: {}\u0026#34;, url); product product = restTemplate.getForObject(url, product.class); return product; } **面试题：**注册中心Nacos如果宕机，那么还能成功完成远程调用吗？\n1.注册中心如果宕机，以前调用过那么可以从示例缓存中获取IP地址，还能成功完成远程调用\n2.注册中心宕机，如果以前没调用过，那么第一次需要在注册中心获取地址，不能完成远程调用\nNacos配置中心 动态刷新 1 @Value(\u0026#34;${xxx}\u0026#34;)获取配置+@RefreshScope实现自动刷新 项目中使用方法：\n1.启动Nacos\n2.导入Nacos作为配置中心的依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 3.在配置文件properties编写配置\n1 2 3 4 spring.application.name=service-order sercer.port=8000 spring.cloud.nacos.server-addr=127.0.0.1:8848 spring.config.import=nacos:service-order.properties //指定导入的配置文件 4.在创建data-id数据集\n要使用这些配置文件，可以使用Value注解加载\n1 2 3 4 5 6 7 8 9 10 11 @Value(\u0026#34;${order.timeout}\u0026#34;) String orderTimeouut; @Value(\u0026#34;${order.auto-confirm}\u0026#34;) String orderConfirm; @GetMapping(\u0026#34;/config\u0026#34;) String config(){ System.out.println(\u0026#34;orderTimeouut:\u0026#34;+orderTimeouut); System.out.println(\u0026#34;orderConfirm:\u0026#34;+orderConfirm); return orderTimeouut+\u0026#34; \u0026#34;+orderConfirm; } 此时如果直接修改Nacos配置文件的值，这个配置文件是不会自动刷新的，如果想要开启自动刷新的话，需要使用注解在类上添加\n1 @RefreshScope //开启配置文件自动刷新注解 一旦项目导入了Nacos的配置中心，那么项目启动前配置文件必须导入Nacos的配置，如果没有导入那么项目会启动报错\n1 2 3 4 两种解决方法 1.禁用Nacos的导入检查 spring.cloud.nacos.config.import-check.enabled=false 2.设置Nacos的导入为可选的，不是必须的 无感知自动刷新 创建一个properties配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.example.properties; import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; @Data @Component @ConfigurationProperties(prefix = \u0026#34;order\u0026#34;) public class OrderProperties { String timeouut; String autoconfirm; } 想要使用配置文件直接依赖注入即可\n1 2 3 4 5 6 7 8 9 10 @Autowired OrderProperties orderProperties; @GetMapping(\u0026#34;/config\u0026#34;) String config(){ System.out.println(\u0026#34;orderTimeouut:\u0026#34;+orderProperties.getTimeout()); System.out.println(\u0026#34;orderConfirm:\u0026#34;+orderProperties.getAutoconfirm()); return orderProperties.getTimeout()+\u0026#34; \u0026#34;+orderProperties.getAutoconfirm(); } 配置监听 先说一个场景：当Nacos的配置文件发生变更时发送邮件给开发者\n项目启动时监听Nacos配置文件变化 1. 获取最新的配置数据 2. 发送邮件通知开发者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.example; import com.alibaba.cloud.nacos.NacosConfigManager; import com.alibaba.nacos.api.config.listener.Listener; import com.alibaba.nacos.client.config.NacosConfigService; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.context.annotation.Bean; import java.util.concurrent.Executor; @EnableDiscoveryClient @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } /** * 项目启动时监听Nacos配置文件变化 * 1. 获取最新的配置数据 * 2. 发送邮件通知开发者 */ @Bean public ApplicationRunner runner(NacosConfigManager nacosConfigManager) { return args -\u0026gt; { NacosConfigService nacosConfigService = (NacosConfigService) nacosConfigManager.getConfigService(); nacosConfigService.addListener( \u0026#34;com.example.OrderProperties\u0026#34;, \u0026#34;defaultGroup\u0026#34;, new Listener() { @Override public Executor getExecutor() { return Runnable::run; // 修正：原代码中的Executor.newFixedThreadPool(4)不正确 } @Override public void receiveConfigInfo(String configInfo) { System.out.println(\u0026#34;配置文件更新了，最新的配置信息为：\u0026#34; + configInfo); // 发送邮件通知开发者 // 此处省略发送邮件的代码 System.out.println(\u0026#34;邮件已发送\u0026#34;); } } ); }; } } 思考：如果Nacos的配置文件数据集和项目中的配置文件有相同项，哪个会生效？\n先导入优先，外部优先，所以Nacos的配置文件会优先生效\n1 2 3 4 5 6 spring.application.name=service-order sercer.port=8000 spring.cloud.nacos.server-addr=127.0.0.1:8848 spring.config.import=nacos:service-order.properties,nacos:common.properties //service-order.properties优先级最高common.properties第二高 spring.cloud.nacos.config.import-check.enabled=false 数据隔离 先说场景：假设现在有这么一个需求：项目有多套环境：开发，测试，生产环境，而每一个环境在每套环境下配置文件都不一样\n难点：区分多套环境，区分多种配置，区分多种微服务该怎么解决\n解决方法：\n使用Namespace名称空间区分多套环境，使用Group分组区分多种微服务，使用Data-id数据集区分多种配置\n如何实现呢？？？\n1.在Nacos的命名空间中新建名称空间\n2.创建好开发测试生产环境的命名空间后，在配置管理者找到对应空间，新增配置\n3.动态切换环境\n在微服务的配置文件中定义命名空间和组名，但是这样子不能实现动态切换环境\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sercer: port: 8000 spring: application: name: service-order cloud: nacos: server-addr: 127.0.0.1:8848 import-check: enabled=false: config: namespace: dev config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order 完整的配置文件如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 sercer: port: 8000 spring: profiles: active: dev //选择dev环境的配置文件 //active：test //选择test环境下的配置文件 application: name: service-order cloud: nacos: server-addr: 127.0.0.1:8848 import-check: enabled=false: config: namespace: ${spring.profiles.active:public} --- //三个杠表示多文档模式 spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order activate: on-profile: dev --- spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order - nacos:redis.properties?group=order activate: on-profile: test --- spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order - nacos:haha.properties?group=order activate: on-profile: prod ","date":"2025-06-08T11:24:22+08:00","image":"https://lserein.github.io/p/nacos/Nacos_hu_5436af82e36fa2df.jpg","permalink":"https://lserein.github.io/p/nacos/","title":"Nacos"}]