[{"content":"OpenFeign\u0026mdash;远程调用 使用OpenFeign进行远程调用 向第三方微服务API发送请求 小Tips：向自己的业务API发送请求直接复制对方业务Controller层方法即可\n前面使用的是restTemplate进行远程调用，但是使用restTemplate进行远程调用比较麻烦，这里我们使用OpenFeign改写代码\n导入依赖，创建ProductFeignClient接口\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-openfeign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 restTemplate package com.example.feign; import com.example.bean.product; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @FeignClient(value = \u0026#34;product-service\u0026#34;) //Feign客户端，指定要请求的服务名称 public interface ProductFeignClient { //MVC注解两套逻辑 //标注在controller上，是接收http请求 //标注在feign上，是用来发送http请求 @GetMapping(\u0026#34;/product/{productId}\u0026#34;) //指定远程服务接口 product getProductById(@PathVariable(\u0026#34;productId\u0026#34;) Long productId); } 将ProductFeignClient进行依赖注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Autowired ProductFeignClient productFeignClient; @Override public order CreateOrder(Long userId, Long productId) { order order = new order(); //调用接口的方法发送请求 product product = productFeignClient.getProductById(productId); //不需要自己在写getProductFromRemote2方法 //product product = getProductFromRemote2(productId); order.setId(1L); //计算订单总金额 order.setTotalAmount(product.getPrice().multiply(new BigDecimal(\u0026#34;10\u0026#34;))); order.setUserId(userId); order.setNikeName(\u0026#34;zhangsan\u0026#34;); order.setAddress(\u0026#34;beijing\u0026#34;); //远程查询商品信息，并设置到订单中 order.setProductList(Arrays.asList(product)); return order; } 第三方API远程调用 比如我不需要像注册中心发请求，我想像第三方API发送请求，如：墨迹天气等等\n使用FeignClient绑定第三方API的URL，根据对应请求方法发送对应请求\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package com.example.feign; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; //https://v.api.aa1.cn/api/api-tianqi-3/index.php?msg=%E5%A4%A9%E6%B4%A5\u0026amp;type=1 @FeignClient(value = \u0026#34;weather\u0026#34;,url = \u0026#34;https://v.api.aa1.cn/api/api-tianqi-3/index.php\u0026#34;) public interface WeatherFeignClient { @GetMapping(\u0026#34;/api/api-tianqi-3/index.php\u0026#34;) String getWeather(@RequestParam(\u0026#34;msg\u0026#34;) String msg, @RequestParam(\u0026#34;type\u0026#34;) String type); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package com.example; import com.example.feign.WeatherFeignClient; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest public class WeatherTest { @Autowired WeatherFeignClient weatherFeignClient; @Test void test(){ String weather = weatherFeignClient.getWeather(\u0026#34;北京\u0026#34;, \u0026#34;1\u0026#34;); System.out.println(weather); } } 客户端负载均衡与服务端负载均衡？\nOpenFeign进阶配置 开启请求日志功能 在yml配置文件中配置日志的范围\n1 2 3 logging: level: com.example.feign: debug 在config配置类中配置一个Bean\n1 2 3 4 @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; } 再次运行测试类，请求的详细信息（请求方法，路径，参数都会展示）\n超时控制 超时有两种超时，连接超时（默认10秒）和读取超时（默认60秒）\n可以新创建一个配置文件，如果其它配置文件想要使用这个配置文件的话只需要引用即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 spring: cloud: openfeign: client: config: product-service: # 只针对product-service服务的配置 connect-timeout: 10000 # 连接超时时间 read-timeout: 10000 # 读取超时时间 logger-level: full # 日志级别 default: # 所有其它服务的默认配置 connect-timeout: 20000 # 连接超时时间 read-timeout: 30000 # 读取超时时间 logger-level: full # 日志级别 重试机制 在config配置类中自定义一个重试器retryer，Spring提供默认的retryer，默认最大重试5次，每次最大间隔1秒\n1 2 3 4 5 @Bean Retryer retryer() { //最多重试3次，每次最大间隔10秒，最小间隔1秒 return new Retryer.Default(1000, 10000, 3); } 拦截器 创建好后可以将这个拦截器在配置文件中声明也可以将它设置为Bean，自动调用拦截\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.example.interceptor; import feign.RequestInterceptor; import feign.RequestTemplate; import org.springframework.stereotype.Component; import java.util.UUID; @Component public class TokenRequestInterceptor implements RequestInterceptor { /* * 请求拦截器需要实现RequestInterceptor接口的apply方法 * 该方法会在请求发送之前被调用 * 可以在该方法中添加请求头、请求参数等 * 这里我们可以通过RequestTemplate对象来添加请求头 * 例如：requestTemplate.header(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34; + token); * */ @Override public void apply(RequestTemplate requestTemplate) { System.out.println(\u0026#34;拦截器执行了\u0026#34;); requestTemplate.header(\u0026#34;Authorization\u0026#34;, UUID.randomUUID().toString()); } } Fallback兜底返回 使用Fallback兜底返回机制需要引入sentinel依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在配置文件中将feign.sentinel.enable设置为true\n1 2 3 feign: sentinel: enabled: true # 开启feign对sentinel的支持 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package com.example.feign.fallback; import com.example.bean.product; import com.example.feign.ProductFeignClient; import org.springframework.stereotype.Component; import java.math.BigDecimal; @Component public class ProductFeignClientFallback implements ProductFeignClient { @Override public product getProductById(Long productId) { System.out.println(\u0026#34;兜底回调\u0026#34;); product product = new product(); product.setId(productId); product.setProductName(\u0026#34;兜底回调商品\u0026#34;); product.setPrice(new BigDecimal(\u0026#34;1000.00\u0026#34;)); product.setNum(10); return product; } } 如果正常请求无法完成请求，那么会走兜底回调方法，返回默认数据\n","date":"2025-06-08T15:08:01+08:00","image":"https://lserein.github.io/p/openfeign/OpenFeign_hu_f854ac1c3ea4ac46.jpg","permalink":"https://lserein.github.io/p/openfeign/","title":"OpenFeign"},{"content":"Nacos\u0026mdash;注册中心\u0026amp;配置中心 Nacos官网| Nacos 配置中心 | Nacos 下载| Nacos 官方社区\n什么是注册中心Nacos Nacos两大核心功能：服务注册与服务发现\n安装Nacos https://nacos.io/download/release-history/?spm=5238cd80.2ef5001f.0.0.3f613b7c4NDiBh\n直接下载zip压缩包，解压后运行即可\n1 startup.cmd -m standalone 访问:http://127.0.0.1:8848/nacos\nNacos服务注册功能 启动微服务 在service-order微服务模块中写一个SpringBoot的启动类\n创建配置文件application.properties\n1 2 3 spring.application.name=service-order //服务名称 sercer.port=8000 //服务启动端口 spring.cloud.nacos.server-addr=127.0.0.1:8848 //nacos地址 此时访问本地nacos服务器，发现nacos中存在service-order即注册成功\n集群模式启动测试 控制台右键复制配置\n编辑配置，将端口改一下运行即可，如下图所示\n此时nacos注册中心实例数就有3个了\nNacos服务发现 开启服务发现功能 在SpringBoot的启动类中添加注解@EnableDiscoveryClient\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package com.example; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @EnableDiscoveryClient //开启服务注册与发现功能 @SpringBootApplication public class ProductApplication { public static void main(String[] args) { SpringApplication.run(ProductApplication.class, args); } } 测试服务发现API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @SpringBootTest public class productTest { @Autowired DiscoveryClient discoveryClient; @Test public void discoveryClient() { // 服务注册与发现功能的测试代码 discoveryClient.getServices().forEach(service -\u0026gt; System.out.println(\u0026#34;service\u0026#34;+service) ); //获取服务的IP和端口信息 discoveryClient.getInstances(\u0026#34;product-service\u0026#34;).forEach(instance -\u0026gt; System.out.println(\u0026#34;instance\u0026#34;+instance.getHost()+\u0026#34;\\n\u0026#34;+instance.getPort()+\u0026#34;\\n\u0026#34;+instance.getUri()) ); } } 使用nacosServiceDiscovery进行服务发现测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired NacosServiceDiscovery nacosServiceDiscovery; //获取服务信息 @Test void nacosServiceDiscovery() throws NacosException { // 服务注册与发现功能的测试代码 nacosServiceDiscovery.getServices().forEach(service -\u0026gt; System.out.println(\u0026#34;service\u0026#34;+service) ); //获取服务的IP和端口信息 nacosServiceDiscovery.getInstances(\u0026#34;product-service\u0026#34;).forEach(instance -\u0026gt; System.out.println(\u0026#34;instance\u0026#34;+instance.getHost()+\u0026#34;\\n\u0026#34;+instance.getPort()) ); } 4.远程调用\u0026mdash;下单场景 远程调用基本流程\n首先要定义两个微服务模块，分别是order模块和product模块，分别在这两个模块中编写对应的逻辑代码，这两个模块不需要写实体类pojo，将所有微服务的实体类抽取出来放到model模块统一管理\norder和product模块要使用实体类直接在pom文件中加载依赖即可，如果不这样做的话如果订单模块要使用product模块就会很麻烦\n负载均衡API测试 根据配置的策略从可用实例中选择一个，默认使用轮询算法，这次调用9001，下次调用9002，在又是9001\n1 2 3 4 5 //在order的pom文件中引入对应依赖 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-loadbalancer\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @SpringBootTest public class LoadBalancerTest { LoadBalancerClient loadBalancerClient; @Test public void test(){ ServiceInstance choose = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose.getHost()+\u0026#34;:\u0026#34;+choose.getPort()); ServiceInstance choose1 = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose1.getHost()+\u0026#34;:\u0026#34;+choose1.getPort()); ServiceInstance choose2 = loadBalancerClient.choose(\u0026#34;product-service\u0026#34;); System.out.println(choose2.getHost()+\u0026#34;:\u0026#34;+choose2.getPort()); } } 使用@LoadBanlancer注解完成负载均衡调用 1 2 3 4 5 6 //将注解放到远程调用客户端上即可 @LoadBalanced @Bean public RestTemplate restTemplate() { return new RestTemplate(); } 1 2 3 4 5 6 7 8 9 10 private product getProductFromRemote2(Long productId) { // 1. 获取商品服务所在的 IP 地址 // 2. 构造请求 URL，product-service微服务的IP地址 String url = \u0026#34;http://product-service/product/\u0026#34; + productId; // 3. 发送请求，获取商品信息 log.info(\u0026#34;请求URL: {}\u0026#34;, url); product product = restTemplate.getForObject(url, product.class); return product; } **面试题：**注册中心Nacos如果宕机，那么还能成功完成远程调用吗？\n1.注册中心如果宕机，以前调用过那么可以从示例缓存中获取IP地址，还能成功完成远程调用\n2.注册中心宕机，如果以前没调用过，那么第一次需要在注册中心获取地址，不能完成远程调用\nNacos配置中心 动态刷新 1 @Value(\u0026#34;${xxx}\u0026#34;)获取配置+@RefreshScope实现自动刷新 项目中使用方法：\n1.启动Nacos\n2.导入Nacos作为配置中心的依赖\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 3.在配置文件properties编写配置\n1 2 3 4 spring.application.name=service-order sercer.port=8000 spring.cloud.nacos.server-addr=127.0.0.1:8848 spring.config.import=nacos:service-order.properties //指定导入的配置文件 4.在创建data-id数据集\n要使用这些配置文件，可以使用Value注解加载\n1 2 3 4 5 6 7 8 9 10 11 @Value(\u0026#34;${order.timeout}\u0026#34;) String orderTimeouut; @Value(\u0026#34;${order.auto-confirm}\u0026#34;) String orderConfirm; @GetMapping(\u0026#34;/config\u0026#34;) String config(){ System.out.println(\u0026#34;orderTimeouut:\u0026#34;+orderTimeouut); System.out.println(\u0026#34;orderConfirm:\u0026#34;+orderConfirm); return orderTimeouut+\u0026#34; \u0026#34;+orderConfirm; } 此时如果直接修改Nacos配置文件的值，这个配置文件是不会自动刷新的，如果想要开启自动刷新的话，需要使用注解在类上添加\n1 @RefreshScope //开启配置文件自动刷新注解 一旦项目导入了Nacos的配置中心，那么项目启动前配置文件必须导入Nacos的配置，如果没有导入那么项目会启动报错\n1 2 3 4 两种解决方法 1.禁用Nacos的导入检查 spring.cloud.nacos.config.import-check.enabled=false 2.设置Nacos的导入为可选的，不是必须的 无感知自动刷新 创建一个properties配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package com.example.properties; import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.stereotype.Component; @Data @Component @ConfigurationProperties(prefix = \u0026#34;order\u0026#34;) public class OrderProperties { String timeouut; String autoconfirm; } 想要使用配置文件直接依赖注入即可\n1 2 3 4 5 6 7 8 9 10 @Autowired OrderProperties orderProperties; @GetMapping(\u0026#34;/config\u0026#34;) String config(){ System.out.println(\u0026#34;orderTimeouut:\u0026#34;+orderProperties.getTimeout()); System.out.println(\u0026#34;orderConfirm:\u0026#34;+orderProperties.getAutoconfirm()); return orderProperties.getTimeout()+\u0026#34; \u0026#34;+orderProperties.getAutoconfirm(); } 配置监听 先说一个场景：当Nacos的配置文件发生变更时发送邮件给开发者\n项目启动时监听Nacos配置文件变化 1. 获取最新的配置数据 2. 发送邮件通知开发者 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.example; import com.alibaba.cloud.nacos.NacosConfigManager; import com.alibaba.nacos.api.config.listener.Listener; import com.alibaba.nacos.client.config.NacosConfigService; import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.context.annotation.Bean; import java.util.concurrent.Executor; @EnableDiscoveryClient @SpringBootApplication public class OrderApplication { public static void main(String[] args) { SpringApplication.run(OrderApplication.class, args); } /** * 项目启动时监听Nacos配置文件变化 * 1. 获取最新的配置数据 * 2. 发送邮件通知开发者 */ @Bean public ApplicationRunner runner(NacosConfigManager nacosConfigManager) { return args -\u0026gt; { NacosConfigService nacosConfigService = (NacosConfigService) nacosConfigManager.getConfigService(); nacosConfigService.addListener( \u0026#34;com.example.OrderProperties\u0026#34;, \u0026#34;defaultGroup\u0026#34;, new Listener() { @Override public Executor getExecutor() { return Runnable::run; // 修正：原代码中的Executor.newFixedThreadPool(4)不正确 } @Override public void receiveConfigInfo(String configInfo) { System.out.println(\u0026#34;配置文件更新了，最新的配置信息为：\u0026#34; + configInfo); // 发送邮件通知开发者 // 此处省略发送邮件的代码 System.out.println(\u0026#34;邮件已发送\u0026#34;); } } ); }; } } 思考：如果Nacos的配置文件数据集和项目中的配置文件有相同项，哪个会生效？\n先导入优先，外部优先，所以Nacos的配置文件会优先生效\n1 2 3 4 5 6 spring.application.name=service-order sercer.port=8000 spring.cloud.nacos.server-addr=127.0.0.1:8848 spring.config.import=nacos:service-order.properties,nacos:common.properties //service-order.properties优先级最高common.properties第二高 spring.cloud.nacos.config.import-check.enabled=false 数据隔离 先说场景：假设现在有这么一个需求：项目有多套环境：开发，测试，生产环境，而每一个环境在每套环境下配置文件都不一样\n难点：区分多套环境，区分多种配置，区分多种微服务该怎么解决\n解决方法：\n使用Namespace名称空间区分多套环境，使用Group分组区分多种微服务，使用Data-id数据集区分多种配置\n如何实现呢？？？\n1.在Nacos的命名空间中新建名称空间\n2.创建好开发测试生产环境的命名空间后，在配置管理者找到对应空间，新增配置\n3.动态切换环境\n在微服务的配置文件中定义命名空间和组名，但是这样子不能实现动态切换环境\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sercer: port: 8000 spring: application: name: service-order cloud: nacos: server-addr: 127.0.0.1:8848 import-check: enabled=false: config: namespace: dev config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order 完整的配置文件如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 sercer: port: 8000 spring: profiles: active: dev //选择dev环境的配置文件 //active：test //选择test环境下的配置文件 application: name: service-order cloud: nacos: server-addr: 127.0.0.1:8848 import-check: enabled=false: config: namespace: ${spring.profiles.active:public} --- //三个杠表示多文档模式 spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order activate: on-profile: dev --- spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order - nacos:redis.properties?group=order activate: on-profile: test --- spring: config: import: - nacos:Common.properties?group=order - nacos:database.properties?group=order - nacos:haha.properties?group=order activate: on-profile: prod ","date":"2025-06-08T11:24:22+08:00","image":"https://lserein.github.io/p/nacos/Nacos_hu_5436af82e36fa2df.jpg","permalink":"https://lserein.github.io/p/nacos/","title":"Nacos"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://lserein.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://lserein.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://lserein.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://lserein.github.io/p/emoji-support/","title":"Emoji Support"}]